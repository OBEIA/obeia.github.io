{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OBEIA CISC/CMPE 322 / CISC 326 Software Architecture W22 Group 35 Welcome Apollo is an \"open autonomous driving platform\" intended for the development of autonomous cars. Initially announced in 2017, it has since developed in various aspects toward driverless driving, with an emphasis on security and safety as the vehicle drives in more complex situations. Methods such as deep learning have been implemented in its software, improving aspects of its autonomy such as perception; further details may be found on its releases page . The architecture of a software system such as Apollo is an integral aspect of its evolution; the system's development is intricately affected by how the architecture has been defined, and any changes or additions may cause a heavy impact to both. Over the course of our project, OBEIA will be studying Apollo to gain an understanding of the development of its architecture, notably that of 7.0. Our site will record our findings from the architecture's concept recovery to its concrete build, ending with a possible enhancement and how the architecture would be affected.","title":"Home"},{"location":"#obeia","text":"CISC/CMPE 322 / CISC 326 Software Architecture W22 Group 35","title":"OBEIA"},{"location":"#welcome","text":"Apollo is an \"open autonomous driving platform\" intended for the development of autonomous cars. Initially announced in 2017, it has since developed in various aspects toward driverless driving, with an emphasis on security and safety as the vehicle drives in more complex situations. Methods such as deep learning have been implemented in its software, improving aspects of its autonomy such as perception; further details may be found on its releases page . The architecture of a software system such as Apollo is an integral aspect of its evolution; the system's development is intricately affected by how the architecture has been defined, and any changes or additions may cause a heavy impact to both. Over the course of our project, OBEIA will be studying Apollo to gain an understanding of the development of its architecture, notably that of 7.0. Our site will record our findings from the architecture's concept recovery to its concrete build, ending with a possible enhancement and how the architecture would be affected.","title":"Welcome"},{"location":"assignment0/","text":"Apollo Resources General Resources Apollo Website Apollo Auto Blog Apollo Auto YouTube Channel Apollo Platform Twitter Policies Project Governance Policy Project Contribution Guide Development Main Source Code Repository Apollo Auto GitHub Organization Apollo Platform Issue Tracker Basic Documentation Release Details Apollo Platform Component Detail Quick Start Guide Index How-To Guide Index FAQ Index Advanced Documentation Apollo Developer Course Technical Tutorial Index Hardware and Software Component Specifications Technical Code Readings and Algorithm Details Domain Research A functional reference architecture for autonomous driving","title":"Apollo Resources"},{"location":"assignment0/#apollo-resources","text":"","title":"Apollo Resources"},{"location":"assignment0/#general-resources","text":"Apollo Website Apollo Auto Blog Apollo Auto YouTube Channel Apollo Platform Twitter","title":"General Resources"},{"location":"assignment0/#policies","text":"Project Governance Policy Project Contribution Guide","title":"Policies"},{"location":"assignment0/#development","text":"Main Source Code Repository Apollo Auto GitHub Organization Apollo Platform Issue Tracker","title":"Development"},{"location":"assignment0/#basic-documentation","text":"Release Details Apollo Platform Component Detail Quick Start Guide Index How-To Guide Index FAQ Index","title":"Basic Documentation"},{"location":"assignment0/#advanced-documentation","text":"Apollo Developer Course Technical Tutorial Index Hardware and Software Component Specifications Technical Code Readings and Algorithm Details","title":"Advanced Documentation"},{"location":"assignment0/#domain-research","text":"A functional reference architecture for autonomous driving","title":"Domain Research"},{"location":"assignment1/","text":"The Conceptual Architecture of Apollo Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.) Abstract Apollo is an open-source autonomous driving platform supporting the development of systems for self-driving vehicles. Such a system must carefully develop its architecture to fulfil the requirements of stakeholders such as investors, developers and users. To extract the software system\u2019s conceptual architecture, we considered a reference architecture created by Sagar Behere and Martin T\u00f6rngren, as well as Apollo\u2019s documentation, notably that found on their current version (7.0) and version 5.5 GitHub pages. This documentation reveals an architecture containing various components mapping to the reference architecture. Apollo\u2019s architecture largely relies on a publish-subscribe style that allows for high concurrency and performance, as well as simplified system evolution. Introduction Software System Apollo is an autonomous driving platform specializing in supporting the development of self-driving vehicles. Initially announced in 2017, the project has since developed from being able to follow GPS Waypoints towards fully \u201cdriverless driving;\u201d as of December 2021, Apollo has reached version 7.0. The system is open-source and documented in detail. [GitHub] Apollo\u2019s Open Software Platform needs a complex system to fulfil the requirements of an autonomously driving vehicle. In particular, the system needs to be able to determine its surroundings and situation, predict how these may change, and plan how the vehicle will move accordingly, ultimately determining the vehicle\u2019s trajectory. These functions must perform efficiently and accurately for the system to run as expected in real-life scenarios that vehicles and their drivers experience. This report studies and describes the conceptual architecture used within the system. Derivation Process Deriving the architecture presented involved reading academic papers as well as the Apollo documentation, including that from previous versions, such as 5.5. Sagar Behere and Martin T\u00f6rngren have formed a functional reference architecture for autonomous driving platforms up to level L4 of autonomy [Behere and T\u00f6rngren 138] . As they discuss, this form of architecture is the starting point for architectural design of a system and may aid in other implementations in the field of focus, in this case, self-driving vehicles. Their reference architecture is depicted in Figure 1; it includes a variety of modules and components relating to the functionality of the vehicle. Figure 1: A functional reference architecture for an autonomous driving platform, as provided by Behere and T\u00f6rngren. [ibid., 143] Components relating to the system\u2019s perception include sensors; a \u201csensor fusion\u201d that forms an idea regarding the environment; a localization component relating to the location of the vehicle; a \u201csemantic understanding\u201d component; and a \u201cworld model\u201d component that describes the external world of the vehicle. These components connect, as shown in detail in Figure 1, to perceive and understand the environment that the vehicle is in. [ibid., 139-140] The decision and control component works to understand the vehicle\u2019s various characteristics, including trajectories it can travel (as well as the \u201coptimal\u201d one) and its energy (electricity, gas, hybrid, etc.). By understanding these characteristics, this component may make the appropriate decisions, hence controlling what the system does. [ibid., 140-141] The vehicle platform itself refers to the internal system, including the execution of trajectories, managing the energy that is noted in the energy sub-component of decision and control, and managing the safety and control of the vehicle, including regularly considering the state of the system via the diagnostics and faults management systems. [ibid., 141] Requirements We initially identified three main categories of stakeholders and their high-level needs based on their type of interaction with the system. Starting at the production end is any stakeholder involved with the design, manufacturing, and selling of the system; this might include engineers, developers, producers, and investors. Their needs are focused on modularity and adaptability; reducing complexity and use of existing resources can lead to faster prototyping and lower costs. The second category are the users who purchase or otherwise own and depend primarily on the functionality of the system. Their needs are convenience (usability, affordability, etc.) and effectiveness. The remaining group of stakeholders is the technical support, whose needs involve diagnostics and modifications. Apollo is a complex platform that has been built over time based on specific driving cases. [GitHub] Understanding the requirements of such a system is integral to its development, particularly as vehicles are an aspect of urban life where safety is essential. For this, any driver must be aware of their surroundings and react accordingly. Thus an autonomous system that imitates a driving experience requires excellent performance\u2014it must be able to react in short periods of time while at the same time driving as accurately as a user (and any person on the road) expects. Being on the road brings a variety of complex situations that must be considered for the system while maintaining good performance. Apollo is a system that connects to the cloud for security purposes, as well as calibration [Baidu] ; the system\u2019s security is important to the safety of those on the road. Apollo offers various products relating to security for its system. IDPS takes note of errors as soon as possible and reports them to the cloud, also preventing them from affecting the entire system. Secure IVI considers applications and prevents unauthorized access by suspicious apps. [Baidu] Authorization is integral to the system, protecting from any potential attackers; encryption may also deter them. Thus, a system such as Apollo must take security seriously. Any autonomous system needs to be reliable, as a user would expect the system to be able to mostly drive on its own and make decisions as appropriate in short periods of time. Such a system must be continuously available. Security systems notice errors within the system and react accordingly, so the system should be as available as possible to ensure errors are noticed; the system being unavailable may also negatively impact safety. Apollo also highlights the importance of its use by other developers interested in the platform, including the implementation of an online development platform dedicated to this development. [GitHub] Modifiability, then, would be an important non-functional requirement for the system to ease these developers in their process. The development process of Apollo from 1.0 to 7.0 has been documented in detail, with summaries on their GitHub release page; a variety of requirements for the system may be extracted from the release summaries alone. These functional requirements include but are not limited to: (1) driving by following GPS signals; (2) cruising, not only in lanes but also in urban roads and on highways; (3) avoiding collisions with other vehicles, objects, pedestrians, etc.; (4) changing lanes as appropriate; (5) stopping at traffic lights; (6) safely turning at intersections; and (7) parking with the appropriate method. Conceptual Architecture Overview Figure 2: Apollo 3.5 software architecture core modules interaction diagram, from the project documentation on GitHub. [GitHub] Figure 2 represents the software architecture of Apollo as of version 3.5. As a top-level view of the architecture, it does not describe the system as closely as the functional reference architecture created by Behere and T\u00f6rngren; however, both architectures feature similar key components, including perception, localization, and control. The planning component in the Apollo architecture may also coincide with the decision and control component of the reference architecture. Figure 3: Description of various aspects of the Apollo 7.0 platform, as highlighted in the project documentation on GitHub. [GitHub] Figure 3 displays key components in the Apollo platforms; the Open Software Platform section of the figure includes some similar components as in the architecture but includes a V2X adapter and Apollo Cyber RT (described below), all running on a real-time operating system (RTOS), as well as a map engine relating to the HD map within the architecture (that is instead shown within the Cloud Service Platform). The Apollo software architecture documentation only extends up to version 5.5, but while it has not been updated for releases 6.0 and 7.0, those have primarily added new deep learning models and developer frontends and have not significantly changed the overall architecture. Studying Apollo\u2019s documentation reveals that the software platform consists of thirteen major subsystems: twelve providing autonomous vehicle functionality, and one providing a communication and runtime framework for the operation of the others. This central runtime is known as Apollo Cyber RT and is described in further detail below. Figure 4: The dependency relations of Apollo\u2019s software modules, derived from descriptions in the project documentation. Figure 5: The communication flow between the core Apollo modules. Using Apollo project documentation, the names and functionality of the major modules of the software platform were identified and their interactions diagrammed as dependency relations in Figure 4. These interactions end up being quite complex. However, the Cyber RT framework provides the communication facilities for the modules to interact, primarily in a publish-subscribe pattern. This allows the system overall to remain largely decoupled, as shown in Figure 5. Subsystems Apollo contains thirteen major modules or subsystems within it: Cyber RT, Perception, Prediction, Planning, Storytelling, Routing, HD Map, Monitor, Dreamview, Guardian, Localization, Control, and CanBus. [GitHub] The following subsections describe these modules and explore how they relate to Behere and T\u00f6rngren\u2019s reference architecture in Figure 1. Cyber RT The central subsystem of Apollo\u2019s architecture is a custom runtime framework known as Cyber RT . This runtime system is responsible for loading and launching the other major components and providing a mechanism for them to communicate with one another. The developers of Apollo describe this component as high concurrency and throughput that allows for high performance; it is specialized for autonomous driving. [GitHub] Using channels (or topics) of Cyber RT, modules communicate in a publish-subscribe manner, allowing for flexibility and decoupling of modules; they may also communicate in a client/server method through this component. [GitHub] Perception The Perception subsystem is a low-level component which takes input directly from physical sensors mounted on a vehicle. These sensors include two forward-facing cameras, four LiDAR sensors with each facing a different direction as well as forward- and rear-facing radar. Stereo images provided by the cameras and LiDAR data are fed to a deep learning model which labels objects in the field of view. Objects are also tracked through each of the sensor systems (camera, radar, LiDAR) and the results amalgamated by the \u201csensor fusion\u201d module. Ultimately this subsystem outputs decisions on the state of nearby traffic lights and a list of objects which are labelled with their type, distance away and velocity. [GitHub] The perception subsystem of Apollo overlaps with some functions of the External Sensing, Sensor Fusion, Semantic Understanding and External World Model subsystems of the reference architecture. Prediction The Prediction subsystem predicts the future movements of objects identified by the perception module. This subsystem takes input from the perception component as well as the localization and planning subsystems. Internal architecture of this system is structured sequentially. The \u201cscenario\u201d submodule characterizes the situation as either cruise, for simple driving in lane, or junction, for driving in an intersection. Then, obstacles are given a priority label which is either \u201ccaution\u201d, \u201cignore\u201d, or \u201cnormal\u201d. The \"evaluator\u201d submodule independently predicts a path and a speed for each obstacle and marks the path with a probability. Finally, a \u201cpredictor\u201d submodule produces an expected trajectory for each obstacle. [GitHub] The prediction subsystem of Apollo performs tasks that are under the Semantic Understanding and External World Model subsystems of the reference architecture. Planning The Planning subsystem is a high-level component that aims to plan the exact route of the vehicle. This subsystem receives data from the Prediction and HD map components to plan short term goals, such as waiting at a traffic light, avoiding a collision, or staying in a lane. Then the planning module receives route data from the Routing module and plans the future trajectory of the vehicle through high-level maneuvers such as executing a three-point turn. In the case where the vehicle is unable to follow the route prescribed by the Routing module, the Planning module may request a new routing computation. [GitHub] The planning module of Apollo is roughly equivalent to the Trajectory system within the control module of the reference architecture. Storytelling The Storytelling subsystem is a high-level scenario manager intended to coordinate inter-module actions. Complex driving scenarios require intensive communication between modules. To avoid a sequential architecture in these situations, the storytelling module creates \u201cstories\u201d; complex scenarios that trigger many other modules. These stories are published and can be subscribed to by any other module. [GitHub] The Storytelling subsystem is specific to the implementation of Apollo and does not have a mapping to the reference architecture. Routing The Routing subsystem generates navigation paths given a target start and end point, using the topology of the terrain. Typically, the end point is the destination of the passenger, and the start point is the current location of the vehicle. This subsystem does high-level navigation using map data and could be compared to a GPS installed in most cars today. A routing map is outputted and used for the lower-level navigation done by Planning. [GitHub] The Routing component of Apollo could be part of the trajectory component of the reference architecture. However, it is unclear whether the reference architecture treats navigation as a Trajectory task, a Localization task or a cloud server task. HD Map The HD Map functions as a query engine for the other modules to provide on demand, high granularity information about the roads. It retrieves map data from the cloud upon request and caches map data for repeated reuse. The information from the HD Map is queried by the routing module to plan high level routes. [GitHub] Apollo\u2019s HD Map has both an onboard client component as well as an offboard server component. There are two possible interpretations of the reference architecture documentation as it pertains to navigation. One possibility is that all map data is stored onboard in the Localization module. Another is that map and routing functions are performed off the vehicle platform. The maps are then remotely sent to the vehicle to contribute to the vehicle\u2019s External World Model. Monitor The Monitor module provides status checks of both hardware and software components of the system. This subsystem surveils all the modules of the vehicle, as well as hardware to ensure they are working as intended. This data is passed to the Dreamview for the passenger to easily view the status of the system. [GitHub] The Monitor component of Apollo has a similar function to Platform Fault Management in the reference architecture. Dreamview Dreamview , Apollo\u2019s HMI module, provides a UI in the form of a web application that allows developers or vehicle passengers to visualize the data produced by other subsystems. Given the inputs of the other modules, Dreamview produces a three-dimensional representation of the vehicle including the current location and planned path. Additionally, using data from the Monitor module, Dreamview displays the status of the components and hardware of the vehicle. [GitHub] Apollo\u2019s Dreamview visualization interface is an example of a service that is performed offboard in the reference architecture, in this case both tele-operation and remote monitoring. Guardian The Guardian module serves as an \u201caction center\u201d that will only react in case of module failure. Using reports sent by the Monitor, the Guardian may do one of two things. If all modules are working as expected, the Guardian allows the process to continue normally. If the Monitor detects failure of some form, the Guardian works to handle the failure by preventing controls from reaching the CanBus, then stopping the vehicle. The Guardian manages two main types of shutdowns. If the sensors are operating normally and do not detect any obstacles the vehicle will enter a controlled slow stop by applying light breaking. In the second scenario, if the sensors are not operating normally, the Guardian applies heavy breaking to bring the car to an immediate stop. [GitHub] Apollo\u2019s Guardian module works with the Monitor module to produce the functions of Platform Management in the reference architecture. Localization The Localization component is a low-level module that provides localization services to other components. Depending on the hardware available in the car, this module can use a combination of GPS, an inertial measurement unit, and LiDAR. The localization component outputs an estimate of the vehicle's location. [GitHub] Apollo\u2019s Localization module is equivalent to the Localization module in the reference architecture. Control The Control component generates control commands for the vehicle to create a \u201ccomfortable driving experience.\u201d Using the localization of the vehicle, the car status, and the trajectory created by the Planning module, commands are created by various algorithms depending on the scenario. Commands include those for the steering, brakes, and throttle, to be used by the chassis. These commands are passed to the CanBus to control the vehicle hardware. [GitHub] Apollo\u2019s Control module is comparable to the Control module in the reference architecture. However, the reference architecture considers several decision-making functions to be within the Control subsystem whereas Apollo\u2019s Control module is separate from its Planning and Guardian, for example. CanBus CanBus works closely with the Control module, acting as the interface between the software system and the physical vehicle chassis. In one direction, the module uses a suite of sensors specific to the vehicle model to report the status of the car to Control. In the other direction, it executes the actions required to actualize the commands sent from Control, such as changing direction, engaging brakes, and accelerating. [GitHub] The CanBus module onboard the Apollo software system is one implementation of the Vehicle Platform Abstraction component of the reference architecture. Concurrency The Cyber RT framework that underlies the other modules of the software platform provides several mechanisms for concurrency. At a high level, it implements a \u201ctask\u201d abstraction to describe asynchronous computing operations. Beyond this, Cyber RT provides different resource scheduling algorithms that developers can choose from to better suit specific scenarios, as well as a coroutine implementation called \u201cCRoutine\u201d that optimizes system resource and thread utilization. [GitHub] Architecture Styles The primary architectural style present in the Apollo software platform is publish-subscribe, which allows the various subsystems to interact in a well-defined and loosely coupled manner. As discussed previously, the Apollo Cyber RT system acts as a message broker in this architecture. Cyber provides an implementation of \u201cchannels\u201d as a mechanism of data communication between the other modules, which can act as either \u201creaders\u201d or \u201cwriters\u201d in respect to a given channel. [GitHub] Acting as a writer, a module publishes messages to a channel, consisting of structured data such as commands, events, or sensor data. When acting as a reader, a module has defined interfaces that handle processing and reacting to messages on subscribed channels according to registered function callbacks. [GitHub] There does not seem to be any limit to how many channels a module can act as a reader or writer on, but each writer interface defines a unique channel to enforce isolation by message \u201ctopic\u201d. There are many benefits to the publish-subscribe model in a system as complex as Apollo. By relying on broadcast events, modules can send out commands or data to other parts of the system without having to lose process control or wait for responses. This is crucial in the domain of autonomous driving as continuous operation of all subsystems is critical for the continuing operation and safety of the vehicle and its occupants. From a development standpoint, the architecture also allows for the various subsystem modules to be independent and isolated, only interacting by certain strict mechanisms and interfaces, and keeping them loosely coupled. It also simplifies future evolution of the system, since the strict interfaces and loose coupling make it easier for modules to be split, replaced, or even removed, and for new modules to be added. However, publish-subscribe is not the only communication mechanism present in the platform, and while it is prevalent enough to define the overall architecture there are certain components that interact according to other patterns. In addition to the publish-subscribe facilities, Cyber RT also provides interfaces for client-server-style interaction, for scenarios requiring two-way request-response communication. [GitHub] One case where this is used seems to be in making ad hoc queries to the HD Map module. Finally, it is worth noting that by using these mechanisms, the Control and CanBus subsystems implement a process control pattern. In this sense, the Control module acts as the controller, creating execution plans for car actions based on requirements and data from the other modules, while the CanBus acts as the process, interfacing with the actual physical vehicle to actualize the commands from Control as well as providing it with feedback from chassis sensors. Use Cases Figure UC0: Sequence diagram of the \u2018loop\u2019 that the Apollo system goes through as it creates the optimal path for the vehicle to go. It is described in the text. Figure UC0 displays how the system logic works in a loop of sorts, in that this process continues to be performed while the vehicle is driven, and the appropriate modules are working. The Localization module must first estimate the location of the vehicle and publish it to Cyber RT, which brokers the data to all subscribed modules. Routing and Storytelling both use the localization data, as well as queried map data from HD Map, to generate a route and a story, respectively. These are published to and brokered by Cyber RT. After receiving data from the sensors, the Perception module then determines obstacles, lanes, and traffic light status (if applicable), which is again published to and brokered by Cyber RT. The Prediction module uses this Perception data, as well as Localization, Routing, and the previous trajectory of Planning, to predict obstacle trajectories and prioritize them. These are published to Cyber RT, then sent to the Planning module; given Localization, Perception, Prediction, Routing, and Storytelling, as well as queried map data, the optimal trajectory is created by Planning. It is published to Cyber RT, then brokered to Prediction and Control. The Control module then generates the appropriate control commands, which are published. If the system is in a good state, then the CanBus retrieves these controls, sending them to the hardware, and publishes chassis data. While these processes are running, the HMI retrieves data using Cyber RT\u2019s channels, displaying them to the user or driver. The Monitor may also retrieve these data, processing them and publishing a report that details the state of the modules; Cyber RT then sends the report to both the HMI and Guardian. The HMI displays the report\u2019s results, while the Guardian ensures that there are no issues. If there are any failures, however, then the Guardian will enact its procedure to handle it as described in Subsystems . Use case 1: Lane following The first use case is the default lane following. In this use case, the vehicle is to stay within its lane and follow another car at a safe distance. First, hardware sensors described in Subsystems feed data to the perception module. The perception module then identifies lane lines as well as the other car, but does not identify any traffic lights in this case. Sensor fusion takes the labelled objects and sensor data to assign the car ahead with a distance and velocity. Lane lines are marked with their distance away. This information is published to Cyber RT and picked up by the prediction module. By identifying that there are currently no traffic lights ahead, the prediction module characterizes the scenario as \u201ccruise\u201d. The leading car is assigned priority \u201ccaution\u201d as it may affect the ego car\u2019s trajectory. Eventually, a trajectory for the leading car is predicted and, in this case, that trajectory is continuing in the lane and either slowing down or speeding up. This trajectory is published to Cyber RT and picked up by Planning. Planning uses the predicted trajectory of the leading car to produce a \u201ccollision-free and comfortable\u201d trajectory for the ego car. In this use case, the trajectory would be to direct the car within the lane and at a speed similar to the leading car. This trajectory is published to Cyber RT and picked up by the control module. The control module uses the planned trajectory along with localization information and car status coming from the CanBus to produce control signals for steering, brakes and throttle. In this case, it would be expected that the steering signal would only change the position of the wheels to follow the lane. Throttle and brake control signals should be mostly neutral as well unless the car ahead is stopping or accelerating quickly. Figure UC1: Sequence diagram for the lane following use case, focusing on the system\u2019s process from Perception to CanBus. Use case 2: Unprotected left turn The second use case to be considered is the \u201cUnprotected Left\u201d scenario described in the details of the Planning module of Apollo 5.5 [GitHub] ; it is one scenario relating to a traffic light that remains within the Planning module [GitHub] . In this use case, the vehicle is to turn left through an intersection with a traffic light to continue to its destination; the term \u201cunprotected\u201d refers to how there is no distinct left/right turn light; the vehicle must yield to oncoming traffic. Specifics of what the vehicle should do are detailed in the README of 5.5\u2019s Planning module. Figure UC2: Sequence diagram of the Planning module\u2019s determination of the optimal trajectory for the given use case of \u201cunprotected left turn.\u201d Figure UC2 highlights the process that the Planning module runs to determine the optimal trajectory for the vehicle. The various inputs that were brokered by Cyber RT are stored; then, the \u201cScenario Decider\u201d determines the scenario that is to be handled: Traffic Light, Unprotected Left. This is done by noting the traffic light status that was determined by Perception. Using this scenario as well as the inputs (particularly route and map), the module plans a path for the vehicle; this is then used by the speed planner (in addition to the input) to determine an optimal speed. If the vehicle needs to stop, then it should slow or stop; otherwise, it should first \u201ccreep\u201d forward to determine if no \u201cobstacles\u201d are present. Once in the intersection, it must yield to oncoming vehicles by slowing down, or otherwise continue driving safely at the appropriate speed for the intersection. This is done by taking note both of obstacles noted by Perception as well as the corresponding predicted trajectories and priorities given by Prediction. Using the path and speed, a trajectory is made and finally sent for other modules such as Control to access. Lessons Learned This report was a complex undertaking and as such we learned a lot in the process of completing it. As it was our group\u2019s first major project together, we learned in the process of it each other\u2019s strengths and weaknesses and styles of working, which will hopefully make planning for future deliverables easier. In respect to the topic itself, we realized just how revealing quality documentation can be, and how much it can reveal about a system on close reading, though its accuracy remains to be seen. To that end, it took us some time to realize how crucial documentation for older versions of Apollo would be to our understanding of the platform, and initially ignoring anything that was not marked for the latest version slowed down initial work significantly. Glossary L4 Autonomy: SAE International has created a standard, \u201cJ3016 Levels of Automated Driving.\u201d These levels range from Level 0 (no automation) to Level 5 (full autonomy). Level 4 (L4) is described as highly automated with features able to drive the vehicle in limited conditions, compared to Level 5 which may drive in all conditions. [SAE] HMI: Human Machine Interface IDPS: Intrusion Detection and Prevention System [Baidu] IVI: In-Vehicle Infotainment LiDAR: Light Detection and Ranging References Apollo Auto. \u201cRobotaxi: Autonomous Driving Solution.\u201d Baidu (2020). Retrieved from https://apollo.auto/robotaxi/index.html. Apollo Auto. \u201cApollo Cyber Security.\u201d Baidu (2020). Retrieved from https://apollo.auto/platform/security.html. ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed February 18, 2022. Retrieved from https://github.com/ApolloAuto/apollo. ApolloAuto. \u201cPlanning README at 5.5.0.\u201d GitHub (2020). Retrieved from https://github.com/ApolloAuto/apollo/blob/r5.5.0/modules/planning/README.md. Behere, Sagar, and Martin T\u00f6rngren. \u201cA functional reference architecture for autonomous driving.\u201d KTH The Royal Institute of Technology, Brinellv\u00e4gen 83, Stockholm SE-10044, Sweden (2015): 143. Retrieved from https://www.sciencedirect.com/science/article/abs/pii/S0950584915002177. Shuttleworth, Jennifer. \u201cSAE Standards News: J3016 automated-driving graphic update.\u201d SAE International (January 7, 2019). Retrieved from https://www.sae.org/news/2019/01/sae-updates-j3016-automated-driving-graphic.","title":"Conceptual Architecture"},{"location":"assignment1/#the-conceptual-architecture-of-apollo","text":"Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.)","title":"The Conceptual Architecture of Apollo"},{"location":"assignment1/#abstract","text":"Apollo is an open-source autonomous driving platform supporting the development of systems for self-driving vehicles. Such a system must carefully develop its architecture to fulfil the requirements of stakeholders such as investors, developers and users. To extract the software system\u2019s conceptual architecture, we considered a reference architecture created by Sagar Behere and Martin T\u00f6rngren, as well as Apollo\u2019s documentation, notably that found on their current version (7.0) and version 5.5 GitHub pages. This documentation reveals an architecture containing various components mapping to the reference architecture. Apollo\u2019s architecture largely relies on a publish-subscribe style that allows for high concurrency and performance, as well as simplified system evolution.","title":"Abstract"},{"location":"assignment1/#introduction","text":"","title":"Introduction"},{"location":"assignment1/#software-system","text":"Apollo is an autonomous driving platform specializing in supporting the development of self-driving vehicles. Initially announced in 2017, the project has since developed from being able to follow GPS Waypoints towards fully \u201cdriverless driving;\u201d as of December 2021, Apollo has reached version 7.0. The system is open-source and documented in detail. [GitHub] Apollo\u2019s Open Software Platform needs a complex system to fulfil the requirements of an autonomously driving vehicle. In particular, the system needs to be able to determine its surroundings and situation, predict how these may change, and plan how the vehicle will move accordingly, ultimately determining the vehicle\u2019s trajectory. These functions must perform efficiently and accurately for the system to run as expected in real-life scenarios that vehicles and their drivers experience. This report studies and describes the conceptual architecture used within the system.","title":"Software System"},{"location":"assignment1/#derivation-process","text":"Deriving the architecture presented involved reading academic papers as well as the Apollo documentation, including that from previous versions, such as 5.5. Sagar Behere and Martin T\u00f6rngren have formed a functional reference architecture for autonomous driving platforms up to level L4 of autonomy [Behere and T\u00f6rngren 138] . As they discuss, this form of architecture is the starting point for architectural design of a system and may aid in other implementations in the field of focus, in this case, self-driving vehicles. Their reference architecture is depicted in Figure 1; it includes a variety of modules and components relating to the functionality of the vehicle. Figure 1: A functional reference architecture for an autonomous driving platform, as provided by Behere and T\u00f6rngren. [ibid., 143] Components relating to the system\u2019s perception include sensors; a \u201csensor fusion\u201d that forms an idea regarding the environment; a localization component relating to the location of the vehicle; a \u201csemantic understanding\u201d component; and a \u201cworld model\u201d component that describes the external world of the vehicle. These components connect, as shown in detail in Figure 1, to perceive and understand the environment that the vehicle is in. [ibid., 139-140] The decision and control component works to understand the vehicle\u2019s various characteristics, including trajectories it can travel (as well as the \u201coptimal\u201d one) and its energy (electricity, gas, hybrid, etc.). By understanding these characteristics, this component may make the appropriate decisions, hence controlling what the system does. [ibid., 140-141] The vehicle platform itself refers to the internal system, including the execution of trajectories, managing the energy that is noted in the energy sub-component of decision and control, and managing the safety and control of the vehicle, including regularly considering the state of the system via the diagnostics and faults management systems. [ibid., 141]","title":"Derivation Process"},{"location":"assignment1/#requirements","text":"We initially identified three main categories of stakeholders and their high-level needs based on their type of interaction with the system. Starting at the production end is any stakeholder involved with the design, manufacturing, and selling of the system; this might include engineers, developers, producers, and investors. Their needs are focused on modularity and adaptability; reducing complexity and use of existing resources can lead to faster prototyping and lower costs. The second category are the users who purchase or otherwise own and depend primarily on the functionality of the system. Their needs are convenience (usability, affordability, etc.) and effectiveness. The remaining group of stakeholders is the technical support, whose needs involve diagnostics and modifications. Apollo is a complex platform that has been built over time based on specific driving cases. [GitHub] Understanding the requirements of such a system is integral to its development, particularly as vehicles are an aspect of urban life where safety is essential. For this, any driver must be aware of their surroundings and react accordingly. Thus an autonomous system that imitates a driving experience requires excellent performance\u2014it must be able to react in short periods of time while at the same time driving as accurately as a user (and any person on the road) expects. Being on the road brings a variety of complex situations that must be considered for the system while maintaining good performance. Apollo is a system that connects to the cloud for security purposes, as well as calibration [Baidu] ; the system\u2019s security is important to the safety of those on the road. Apollo offers various products relating to security for its system. IDPS takes note of errors as soon as possible and reports them to the cloud, also preventing them from affecting the entire system. Secure IVI considers applications and prevents unauthorized access by suspicious apps. [Baidu] Authorization is integral to the system, protecting from any potential attackers; encryption may also deter them. Thus, a system such as Apollo must take security seriously. Any autonomous system needs to be reliable, as a user would expect the system to be able to mostly drive on its own and make decisions as appropriate in short periods of time. Such a system must be continuously available. Security systems notice errors within the system and react accordingly, so the system should be as available as possible to ensure errors are noticed; the system being unavailable may also negatively impact safety. Apollo also highlights the importance of its use by other developers interested in the platform, including the implementation of an online development platform dedicated to this development. [GitHub] Modifiability, then, would be an important non-functional requirement for the system to ease these developers in their process. The development process of Apollo from 1.0 to 7.0 has been documented in detail, with summaries on their GitHub release page; a variety of requirements for the system may be extracted from the release summaries alone. These functional requirements include but are not limited to: (1) driving by following GPS signals; (2) cruising, not only in lanes but also in urban roads and on highways; (3) avoiding collisions with other vehicles, objects, pedestrians, etc.; (4) changing lanes as appropriate; (5) stopping at traffic lights; (6) safely turning at intersections; and (7) parking with the appropriate method.","title":"Requirements"},{"location":"assignment1/#conceptual-architecture","text":"","title":"Conceptual Architecture"},{"location":"assignment1/#overview","text":"Figure 2: Apollo 3.5 software architecture core modules interaction diagram, from the project documentation on GitHub. [GitHub] Figure 2 represents the software architecture of Apollo as of version 3.5. As a top-level view of the architecture, it does not describe the system as closely as the functional reference architecture created by Behere and T\u00f6rngren; however, both architectures feature similar key components, including perception, localization, and control. The planning component in the Apollo architecture may also coincide with the decision and control component of the reference architecture. Figure 3: Description of various aspects of the Apollo 7.0 platform, as highlighted in the project documentation on GitHub. [GitHub] Figure 3 displays key components in the Apollo platforms; the Open Software Platform section of the figure includes some similar components as in the architecture but includes a V2X adapter and Apollo Cyber RT (described below), all running on a real-time operating system (RTOS), as well as a map engine relating to the HD map within the architecture (that is instead shown within the Cloud Service Platform). The Apollo software architecture documentation only extends up to version 5.5, but while it has not been updated for releases 6.0 and 7.0, those have primarily added new deep learning models and developer frontends and have not significantly changed the overall architecture. Studying Apollo\u2019s documentation reveals that the software platform consists of thirteen major subsystems: twelve providing autonomous vehicle functionality, and one providing a communication and runtime framework for the operation of the others. This central runtime is known as Apollo Cyber RT and is described in further detail below. Figure 4: The dependency relations of Apollo\u2019s software modules, derived from descriptions in the project documentation. Figure 5: The communication flow between the core Apollo modules. Using Apollo project documentation, the names and functionality of the major modules of the software platform were identified and their interactions diagrammed as dependency relations in Figure 4. These interactions end up being quite complex. However, the Cyber RT framework provides the communication facilities for the modules to interact, primarily in a publish-subscribe pattern. This allows the system overall to remain largely decoupled, as shown in Figure 5.","title":"Overview"},{"location":"assignment1/#subsystems","text":"Apollo contains thirteen major modules or subsystems within it: Cyber RT, Perception, Prediction, Planning, Storytelling, Routing, HD Map, Monitor, Dreamview, Guardian, Localization, Control, and CanBus. [GitHub] The following subsections describe these modules and explore how they relate to Behere and T\u00f6rngren\u2019s reference architecture in Figure 1.","title":"Subsystems"},{"location":"assignment1/#cyber-rt","text":"The central subsystem of Apollo\u2019s architecture is a custom runtime framework known as Cyber RT . This runtime system is responsible for loading and launching the other major components and providing a mechanism for them to communicate with one another. The developers of Apollo describe this component as high concurrency and throughput that allows for high performance; it is specialized for autonomous driving. [GitHub] Using channels (or topics) of Cyber RT, modules communicate in a publish-subscribe manner, allowing for flexibility and decoupling of modules; they may also communicate in a client/server method through this component. [GitHub]","title":"Cyber RT"},{"location":"assignment1/#perception","text":"The Perception subsystem is a low-level component which takes input directly from physical sensors mounted on a vehicle. These sensors include two forward-facing cameras, four LiDAR sensors with each facing a different direction as well as forward- and rear-facing radar. Stereo images provided by the cameras and LiDAR data are fed to a deep learning model which labels objects in the field of view. Objects are also tracked through each of the sensor systems (camera, radar, LiDAR) and the results amalgamated by the \u201csensor fusion\u201d module. Ultimately this subsystem outputs decisions on the state of nearby traffic lights and a list of objects which are labelled with their type, distance away and velocity. [GitHub] The perception subsystem of Apollo overlaps with some functions of the External Sensing, Sensor Fusion, Semantic Understanding and External World Model subsystems of the reference architecture.","title":"Perception"},{"location":"assignment1/#prediction","text":"The Prediction subsystem predicts the future movements of objects identified by the perception module. This subsystem takes input from the perception component as well as the localization and planning subsystems. Internal architecture of this system is structured sequentially. The \u201cscenario\u201d submodule characterizes the situation as either cruise, for simple driving in lane, or junction, for driving in an intersection. Then, obstacles are given a priority label which is either \u201ccaution\u201d, \u201cignore\u201d, or \u201cnormal\u201d. The \"evaluator\u201d submodule independently predicts a path and a speed for each obstacle and marks the path with a probability. Finally, a \u201cpredictor\u201d submodule produces an expected trajectory for each obstacle. [GitHub] The prediction subsystem of Apollo performs tasks that are under the Semantic Understanding and External World Model subsystems of the reference architecture.","title":"Prediction"},{"location":"assignment1/#planning","text":"The Planning subsystem is a high-level component that aims to plan the exact route of the vehicle. This subsystem receives data from the Prediction and HD map components to plan short term goals, such as waiting at a traffic light, avoiding a collision, or staying in a lane. Then the planning module receives route data from the Routing module and plans the future trajectory of the vehicle through high-level maneuvers such as executing a three-point turn. In the case where the vehicle is unable to follow the route prescribed by the Routing module, the Planning module may request a new routing computation. [GitHub] The planning module of Apollo is roughly equivalent to the Trajectory system within the control module of the reference architecture.","title":"Planning"},{"location":"assignment1/#storytelling","text":"The Storytelling subsystem is a high-level scenario manager intended to coordinate inter-module actions. Complex driving scenarios require intensive communication between modules. To avoid a sequential architecture in these situations, the storytelling module creates \u201cstories\u201d; complex scenarios that trigger many other modules. These stories are published and can be subscribed to by any other module. [GitHub] The Storytelling subsystem is specific to the implementation of Apollo and does not have a mapping to the reference architecture.","title":"Storytelling"},{"location":"assignment1/#routing","text":"The Routing subsystem generates navigation paths given a target start and end point, using the topology of the terrain. Typically, the end point is the destination of the passenger, and the start point is the current location of the vehicle. This subsystem does high-level navigation using map data and could be compared to a GPS installed in most cars today. A routing map is outputted and used for the lower-level navigation done by Planning. [GitHub] The Routing component of Apollo could be part of the trajectory component of the reference architecture. However, it is unclear whether the reference architecture treats navigation as a Trajectory task, a Localization task or a cloud server task.","title":"Routing"},{"location":"assignment1/#hd-map","text":"The HD Map functions as a query engine for the other modules to provide on demand, high granularity information about the roads. It retrieves map data from the cloud upon request and caches map data for repeated reuse. The information from the HD Map is queried by the routing module to plan high level routes. [GitHub] Apollo\u2019s HD Map has both an onboard client component as well as an offboard server component. There are two possible interpretations of the reference architecture documentation as it pertains to navigation. One possibility is that all map data is stored onboard in the Localization module. Another is that map and routing functions are performed off the vehicle platform. The maps are then remotely sent to the vehicle to contribute to the vehicle\u2019s External World Model.","title":"HD Map"},{"location":"assignment1/#monitor","text":"The Monitor module provides status checks of both hardware and software components of the system. This subsystem surveils all the modules of the vehicle, as well as hardware to ensure they are working as intended. This data is passed to the Dreamview for the passenger to easily view the status of the system. [GitHub] The Monitor component of Apollo has a similar function to Platform Fault Management in the reference architecture.","title":"Monitor"},{"location":"assignment1/#dreamview","text":"Dreamview , Apollo\u2019s HMI module, provides a UI in the form of a web application that allows developers or vehicle passengers to visualize the data produced by other subsystems. Given the inputs of the other modules, Dreamview produces a three-dimensional representation of the vehicle including the current location and planned path. Additionally, using data from the Monitor module, Dreamview displays the status of the components and hardware of the vehicle. [GitHub] Apollo\u2019s Dreamview visualization interface is an example of a service that is performed offboard in the reference architecture, in this case both tele-operation and remote monitoring.","title":"Dreamview"},{"location":"assignment1/#guardian","text":"The Guardian module serves as an \u201caction center\u201d that will only react in case of module failure. Using reports sent by the Monitor, the Guardian may do one of two things. If all modules are working as expected, the Guardian allows the process to continue normally. If the Monitor detects failure of some form, the Guardian works to handle the failure by preventing controls from reaching the CanBus, then stopping the vehicle. The Guardian manages two main types of shutdowns. If the sensors are operating normally and do not detect any obstacles the vehicle will enter a controlled slow stop by applying light breaking. In the second scenario, if the sensors are not operating normally, the Guardian applies heavy breaking to bring the car to an immediate stop. [GitHub] Apollo\u2019s Guardian module works with the Monitor module to produce the functions of Platform Management in the reference architecture.","title":"Guardian"},{"location":"assignment1/#localization","text":"The Localization component is a low-level module that provides localization services to other components. Depending on the hardware available in the car, this module can use a combination of GPS, an inertial measurement unit, and LiDAR. The localization component outputs an estimate of the vehicle's location. [GitHub] Apollo\u2019s Localization module is equivalent to the Localization module in the reference architecture.","title":"Localization"},{"location":"assignment1/#control","text":"The Control component generates control commands for the vehicle to create a \u201ccomfortable driving experience.\u201d Using the localization of the vehicle, the car status, and the trajectory created by the Planning module, commands are created by various algorithms depending on the scenario. Commands include those for the steering, brakes, and throttle, to be used by the chassis. These commands are passed to the CanBus to control the vehicle hardware. [GitHub] Apollo\u2019s Control module is comparable to the Control module in the reference architecture. However, the reference architecture considers several decision-making functions to be within the Control subsystem whereas Apollo\u2019s Control module is separate from its Planning and Guardian, for example.","title":"Control"},{"location":"assignment1/#canbus","text":"CanBus works closely with the Control module, acting as the interface between the software system and the physical vehicle chassis. In one direction, the module uses a suite of sensors specific to the vehicle model to report the status of the car to Control. In the other direction, it executes the actions required to actualize the commands sent from Control, such as changing direction, engaging brakes, and accelerating. [GitHub] The CanBus module onboard the Apollo software system is one implementation of the Vehicle Platform Abstraction component of the reference architecture.","title":"CanBus"},{"location":"assignment1/#concurrency","text":"The Cyber RT framework that underlies the other modules of the software platform provides several mechanisms for concurrency. At a high level, it implements a \u201ctask\u201d abstraction to describe asynchronous computing operations. Beyond this, Cyber RT provides different resource scheduling algorithms that developers can choose from to better suit specific scenarios, as well as a coroutine implementation called \u201cCRoutine\u201d that optimizes system resource and thread utilization. [GitHub]","title":"Concurrency"},{"location":"assignment1/#architecture-styles","text":"The primary architectural style present in the Apollo software platform is publish-subscribe, which allows the various subsystems to interact in a well-defined and loosely coupled manner. As discussed previously, the Apollo Cyber RT system acts as a message broker in this architecture. Cyber provides an implementation of \u201cchannels\u201d as a mechanism of data communication between the other modules, which can act as either \u201creaders\u201d or \u201cwriters\u201d in respect to a given channel. [GitHub] Acting as a writer, a module publishes messages to a channel, consisting of structured data such as commands, events, or sensor data. When acting as a reader, a module has defined interfaces that handle processing and reacting to messages on subscribed channels according to registered function callbacks. [GitHub] There does not seem to be any limit to how many channels a module can act as a reader or writer on, but each writer interface defines a unique channel to enforce isolation by message \u201ctopic\u201d. There are many benefits to the publish-subscribe model in a system as complex as Apollo. By relying on broadcast events, modules can send out commands or data to other parts of the system without having to lose process control or wait for responses. This is crucial in the domain of autonomous driving as continuous operation of all subsystems is critical for the continuing operation and safety of the vehicle and its occupants. From a development standpoint, the architecture also allows for the various subsystem modules to be independent and isolated, only interacting by certain strict mechanisms and interfaces, and keeping them loosely coupled. It also simplifies future evolution of the system, since the strict interfaces and loose coupling make it easier for modules to be split, replaced, or even removed, and for new modules to be added. However, publish-subscribe is not the only communication mechanism present in the platform, and while it is prevalent enough to define the overall architecture there are certain components that interact according to other patterns. In addition to the publish-subscribe facilities, Cyber RT also provides interfaces for client-server-style interaction, for scenarios requiring two-way request-response communication. [GitHub] One case where this is used seems to be in making ad hoc queries to the HD Map module. Finally, it is worth noting that by using these mechanisms, the Control and CanBus subsystems implement a process control pattern. In this sense, the Control module acts as the controller, creating execution plans for car actions based on requirements and data from the other modules, while the CanBus acts as the process, interfacing with the actual physical vehicle to actualize the commands from Control as well as providing it with feedback from chassis sensors.","title":"Architecture Styles"},{"location":"assignment1/#use-cases","text":"Figure UC0: Sequence diagram of the \u2018loop\u2019 that the Apollo system goes through as it creates the optimal path for the vehicle to go. It is described in the text. Figure UC0 displays how the system logic works in a loop of sorts, in that this process continues to be performed while the vehicle is driven, and the appropriate modules are working. The Localization module must first estimate the location of the vehicle and publish it to Cyber RT, which brokers the data to all subscribed modules. Routing and Storytelling both use the localization data, as well as queried map data from HD Map, to generate a route and a story, respectively. These are published to and brokered by Cyber RT. After receiving data from the sensors, the Perception module then determines obstacles, lanes, and traffic light status (if applicable), which is again published to and brokered by Cyber RT. The Prediction module uses this Perception data, as well as Localization, Routing, and the previous trajectory of Planning, to predict obstacle trajectories and prioritize them. These are published to Cyber RT, then sent to the Planning module; given Localization, Perception, Prediction, Routing, and Storytelling, as well as queried map data, the optimal trajectory is created by Planning. It is published to Cyber RT, then brokered to Prediction and Control. The Control module then generates the appropriate control commands, which are published. If the system is in a good state, then the CanBus retrieves these controls, sending them to the hardware, and publishes chassis data. While these processes are running, the HMI retrieves data using Cyber RT\u2019s channels, displaying them to the user or driver. The Monitor may also retrieve these data, processing them and publishing a report that details the state of the modules; Cyber RT then sends the report to both the HMI and Guardian. The HMI displays the report\u2019s results, while the Guardian ensures that there are no issues. If there are any failures, however, then the Guardian will enact its procedure to handle it as described in Subsystems .","title":"Use Cases"},{"location":"assignment1/#use-case-1-lane-following","text":"The first use case is the default lane following. In this use case, the vehicle is to stay within its lane and follow another car at a safe distance. First, hardware sensors described in Subsystems feed data to the perception module. The perception module then identifies lane lines as well as the other car, but does not identify any traffic lights in this case. Sensor fusion takes the labelled objects and sensor data to assign the car ahead with a distance and velocity. Lane lines are marked with their distance away. This information is published to Cyber RT and picked up by the prediction module. By identifying that there are currently no traffic lights ahead, the prediction module characterizes the scenario as \u201ccruise\u201d. The leading car is assigned priority \u201ccaution\u201d as it may affect the ego car\u2019s trajectory. Eventually, a trajectory for the leading car is predicted and, in this case, that trajectory is continuing in the lane and either slowing down or speeding up. This trajectory is published to Cyber RT and picked up by Planning. Planning uses the predicted trajectory of the leading car to produce a \u201ccollision-free and comfortable\u201d trajectory for the ego car. In this use case, the trajectory would be to direct the car within the lane and at a speed similar to the leading car. This trajectory is published to Cyber RT and picked up by the control module. The control module uses the planned trajectory along with localization information and car status coming from the CanBus to produce control signals for steering, brakes and throttle. In this case, it would be expected that the steering signal would only change the position of the wheels to follow the lane. Throttle and brake control signals should be mostly neutral as well unless the car ahead is stopping or accelerating quickly. Figure UC1: Sequence diagram for the lane following use case, focusing on the system\u2019s process from Perception to CanBus.","title":"Use case 1: Lane following"},{"location":"assignment1/#use-case-2-unprotected-left-turn","text":"The second use case to be considered is the \u201cUnprotected Left\u201d scenario described in the details of the Planning module of Apollo 5.5 [GitHub] ; it is one scenario relating to a traffic light that remains within the Planning module [GitHub] . In this use case, the vehicle is to turn left through an intersection with a traffic light to continue to its destination; the term \u201cunprotected\u201d refers to how there is no distinct left/right turn light; the vehicle must yield to oncoming traffic. Specifics of what the vehicle should do are detailed in the README of 5.5\u2019s Planning module. Figure UC2: Sequence diagram of the Planning module\u2019s determination of the optimal trajectory for the given use case of \u201cunprotected left turn.\u201d Figure UC2 highlights the process that the Planning module runs to determine the optimal trajectory for the vehicle. The various inputs that were brokered by Cyber RT are stored; then, the \u201cScenario Decider\u201d determines the scenario that is to be handled: Traffic Light, Unprotected Left. This is done by noting the traffic light status that was determined by Perception. Using this scenario as well as the inputs (particularly route and map), the module plans a path for the vehicle; this is then used by the speed planner (in addition to the input) to determine an optimal speed. If the vehicle needs to stop, then it should slow or stop; otherwise, it should first \u201ccreep\u201d forward to determine if no \u201cobstacles\u201d are present. Once in the intersection, it must yield to oncoming vehicles by slowing down, or otherwise continue driving safely at the appropriate speed for the intersection. This is done by taking note both of obstacles noted by Perception as well as the corresponding predicted trajectories and priorities given by Prediction. Using the path and speed, a trajectory is made and finally sent for other modules such as Control to access.","title":"Use case 2: Unprotected left turn"},{"location":"assignment1/#lessons-learned","text":"This report was a complex undertaking and as such we learned a lot in the process of completing it. As it was our group\u2019s first major project together, we learned in the process of it each other\u2019s strengths and weaknesses and styles of working, which will hopefully make planning for future deliverables easier. In respect to the topic itself, we realized just how revealing quality documentation can be, and how much it can reveal about a system on close reading, though its accuracy remains to be seen. To that end, it took us some time to realize how crucial documentation for older versions of Apollo would be to our understanding of the platform, and initially ignoring anything that was not marked for the latest version slowed down initial work significantly.","title":"Lessons Learned"},{"location":"assignment1/#glossary","text":"L4 Autonomy: SAE International has created a standard, \u201cJ3016 Levels of Automated Driving.\u201d These levels range from Level 0 (no automation) to Level 5 (full autonomy). Level 4 (L4) is described as highly automated with features able to drive the vehicle in limited conditions, compared to Level 5 which may drive in all conditions. [SAE] HMI: Human Machine Interface IDPS: Intrusion Detection and Prevention System [Baidu] IVI: In-Vehicle Infotainment LiDAR: Light Detection and Ranging","title":"Glossary"},{"location":"assignment1/#references","text":"Apollo Auto. \u201cRobotaxi: Autonomous Driving Solution.\u201d Baidu (2020). Retrieved from https://apollo.auto/robotaxi/index.html. Apollo Auto. \u201cApollo Cyber Security.\u201d Baidu (2020). Retrieved from https://apollo.auto/platform/security.html. ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed February 18, 2022. Retrieved from https://github.com/ApolloAuto/apollo. ApolloAuto. \u201cPlanning README at 5.5.0.\u201d GitHub (2020). Retrieved from https://github.com/ApolloAuto/apollo/blob/r5.5.0/modules/planning/README.md. Behere, Sagar, and Martin T\u00f6rngren. \u201cA functional reference architecture for autonomous driving.\u201d KTH The Royal Institute of Technology, Brinellv\u00e4gen 83, Stockholm SE-10044, Sweden (2015): 143. Retrieved from https://www.sciencedirect.com/science/article/abs/pii/S0950584915002177. Shuttleworth, Jennifer. \u201cSAE Standards News: J3016 automated-driving graphic update.\u201d SAE International (January 7, 2019). Retrieved from https://www.sae.org/news/2019/01/sae-updates-j3016-automated-driving-graphic.","title":"References"},{"location":"assignment2/","text":"The Concrete Architecture of Apollo Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.) Abstract As an open-source autonomous driving platform, Apollo understandably is a complex system. Having developed greatly over the years, its architecture has changed over time; thus, its concrete architecture may vary from the conceptual architecture derived from its documentation. To derive the concrete architecture, the Understand 5.1 tool, GitHub repository, and a publish-subscribe communication visualization diagram were utilized to determine dependencies between modules. This process confirmed the publish-subscribe, process-control, and client-server architectural styles determined in the conceptual architecture, but also added three new modules\u2014Drivers, Common, and Task Manager\u2014as well as updated the Map module; various discrepancies were found in the Reflexion Analysis process, including direct code dependencies. The Prediction submodule was also studied in this process, revealing that this module utilizes a combination of the object-oriented and publish-subscribe styles in its predicting of obstacle trajectories, with four core sub-modules: Container, Scenario, Evaluator and Predictor. Introduction Apollo is an open-source platform dedicated to the development and testing of autonomously driving vehicles. As a system that values security and safety while maintaining good performance, Apollo\u2019s developers have created a complex system that largely uses the publish-subscribe style. The system contains a variety of subsystems that provide its functionality while satisfying its requirements, including a Perception module to determine obstacles and details, a Prediction module to predict how the surrounding world and obstacles may change, a Planning module that plans the vehicle\u2019s trajectory, and a Control module that transforms the trajectory into commands for the vehicle to deploy. A conceptual architecture was created by studying a reference architecture [Behere and T\u00f6rngren] as well as utilizing Apollo\u2019s documentation. Although the conceptual architecture may describe the system of Apollo to a degree, there are always limitations to what may be extracted via a reference architecture or system documentation. It may deviate from the reference architecture; the documentation may be a work in progress for the system\u2019s current state, and/or omit minor dependencies. Thus, to fully understand Apollo, one must study its code to determine its concrete architecture. To derive the concrete architectures of both Apollo as a whole and our chosen subsystem, Prediction, we used the Understand tool at version 5.1, as well as a graph visualization of the publish-subscribe communication within the system, and in-depth investigation of the source code. Dependencies found within these visualizations were compared to our conceptual architecture, and discrepancies were added or removed as necessary. These discrepancies were studied in further detail to understand them in various ways, including their purpose and timing. Studying Apollo\u2019s source code reveals three additional modules: Drivers, Task Manager and Common, as well as a module, Map, which contains a component of our conceptual architecture, HD Map, as a sub-component. In addition, although publish-subscribe remains largely what the system is built on, Apollo utilizes direct dependencies in its functionality, particularly to the Map module as well as a Common module, and various calls to include files from different components that help in other components\u2019 function. Derivation Process Figures 1 and 2 visualize the conceptual architecture that was derived from Apollo documentation and the reference architecture. Figure 1 highlights the dependency relations between various modules, while Figure 2 emphasizes the architectural style that Apollo is largely built upon: the publish-subscribe style, where modules publish and subscribe to topics of interest as their main form of communication with one another. Figure 1: Dependency relations of the Apollo architecture, as determined in the conceptual architecture retrieval process. (Corrected to match conceptual architecture report text.) Figure 2: Communication flow within the Apollo conceptual architecture. The conceptual architecture retrieved from various Apollo- and autonomous driving-related sources is an essential aspect of determining and understanding the concrete architecture used by the system. The process of deriving this conceptual architecture, as well as its details, may be found in our previous report. [OBEIA] Understand, Publish-Subscribe and Reflection One way to derive the concrete architecture of a system is by studying its source code, taking note of when modules and files within them reference other modules, suggesting a dependency. One method of doing so is via the Understand program. Using a file for this program provided by our instructor, we applied Understand 5.1\u2019s dependency diagram tool; this process produces a visual of the dependencies of the system and allows one to view their specifics. However, due to the publish-subscribe style relying upon a central bus, many dependencies are obscured. To mediate this, our instructor provided another diagram, shown in Figure 3, representing the communication between modules in this style. Using these diagrams, we regularly considered our conceptual architecture, adding and removing dependencies as necessary; in considering these dependencies within Understand, we removed test files that did not affect the system itself. When reviewing discrepancies, we also discerned their purpose, timing, and attribution, if applicable, provided in Reflexion Analysis. In our study of the source code, three new modules or sub-components were found: a common module, a task manager, and drivers. Further, rather than HD Map, there is a \u201cMap\u201d module containing the HD Map as a sub-component. These modules are described in further detail with other subsystems of Apollo, within the Concrete Architecture section. The dependency diagrams and publish-subscribe visualization highlight many different dependencies through the system, notably various dependencies that do not occur within the publish-subscribe communication flow. Some dependencies recorded in our conceptual architecture were missing, whereas many unanticipated dependencies were found. Figure 3: Publish-subscribe communication visualization within Apollo. Concrete Architecture Figures 4 and 5 present the concrete architecture of Apollo\u2019s software system as code dependencies, Figure 6 presents the architecture as messaging dependencies between modules. The architecture and interactions are described further in the following sub-sections. Figure 4: Apollo system inter-module code dependencies, according to Understand 5.1. Figure 5: Simplified view of Apollo inter-module dependencies. Figure 6: Publish-subscribe communication of the concrete Apollo architecture. Modules and Subsystems Cyber RT Apollo\u2019s architecture is built around a custom runtime framework called Cyber RT . Cyber RT has many responsibilities as both a runtime component and a base library for other system modules. At runtime, Cyber manages module loading and most of the inter- and even intra-module communication, through facilities for either publish-subscribe messaging or client-server interaction. Cyber RT also provides code dependencies, including runtime base classes, and utilities for file operations, logging, timing, concurrency, and asynchrony. The publish-subscribe functionality is done through a \u201cchannel\u201d abstraction over multiple transport types, allowing it to be suited for various deployment scenarios. The cyber::Reader class template allows construction of subscribers to a channel and to receive messages on it, either declaring a callback function to trigger when a message is received or allowing messages to be cached for later observation. In many cases, the callback function is simply to store the message so a reference to the latest one is available for use. Publishing to a channel is handled by specializations of the cyber::Writer class template, which can write a single message type to a single channel. On the wire, exchanged messages are byte streams in the protocol buffer (protobuf) encoding format. Each module includes a collection of .proto files which define the messages it sends. Code is generated from the .proto files at build time, which is used by the publishing module for message serialization, and by the subscribing module(s) for deserialization. The Apollo runtime modules are made up of one or more Cyber RT \u201ccomponents\u201d. There are two component base classes that a module can inherit from: cyber::Component (and its various partial specializations) and cyber::TimerComponent . Components inheriting from cyber::Component can declare zero to four message types to listen for and have their main processing logic automatically triggered when a message is received on those channels. Components inheriting from cyber::TimerComponent are instead triggered on certain time intervals. Either type of component can declare additional Reader s, and as many Writer s as required. All components must be registered with Cyber RT to operate. The fundamental nature of Cyber RT means that all other operating subsystems of Apollo depend on it. Common While not a running module that provides specific functionality to the system, the Common module contains useful code that other modules may rely on. The contents include global constants (in the form of gflags ) for topic names, vehicle configuration and data, access to system-wide parameters through a key-value database, latency recording and monitor logging, operation statuses, protocol buffer definitions that see use across the entire system, various math and parsing utilities, and a class that models the overall vehicle state, among others. [GitHub] As it is not a runtime module, Common does not exist as a Cyber RT component. Other than Cyber RT, every analyzed Apollo subsystem relies on Common. Drivers The Drivers module contains code for interfacing with the various hardware components of the Apollo vehicle platform. It contains CAN client code, used both for reading from typical chassis sensors and controlling the vehicle. Additionally, it contains interfaces for the more advanced sensing equipment required for autonomous vehicle operation, including cameras, microphones, LiDAR, radar, and GNSS. These sensors are bridged into the rest of the system by Cyber RT components that write their readings to channels for other modules to read. Some Drivers components are subscribed to messages from the Localization and Canbus modules, relying on them for operational information. Guardian Guardian acts as Apollo\u2019s emergency response system, implemented as a Cyber RT TimerComponent . All messages from Control to Canbus pass through Guardian, which decides whether to block them based on vehicle and system status it receives from Canbus and Monitor. In the event of a system error, Control commands will be blocked, and Guardian will instead direct Canbus to bring the vehicle to a stop. Monitor Monitor is a cyber::TimerComponent that regularly checks the status of the hardware and software of the system, using various mechanisms including OS-level process checks, and status messages on most Cyber RT channels. It reports results on the SystemStatus channel and is also able to directly update Dreamview. Dreamview Apollo\u2019s HMI module, Dreamview , includes a JavaScript frontend that allows users to visualize the data produced by other subsystems, and an on-board backend. Dreamview reads messages from all other modules and produces a three-dimensional representation of the vehicle including the current location and planned path and displays the status of the system components and hardware. Additionally, Dreamview contains a map service that other modules rely on, and an interface to allow certain HMI actions to be carried out. Perception The Perception subsystem takes input from physical sensors mounted on a vehicle, including cameras, LiDAR sensors, and radar, over channels from the Drivers module. This subsystem outputs decisions on the state of nearby traffic lights and a list of objects which are labelled with their type, distance from the vehicle, and velocity. [GitHub] The module is quite complex and includes ten different Cyber RT components. Prediction The Prediction subsystem predicts the future movements of objects identified by the perception module, implemented as a cyber::Component that is triggered by the publishing of PerceptionObstacles messages. [GitHub] This module is described in more detail in the Subsystem: Prediction section of this report. In addition to Perception, the module reads from Storytelling, Map, and Localization subsystem channels. Planning The Planning subsystem aims to plan the exact route of the vehicle. It first plans short term goals such as staying in a lane, then plans the future trajectory of the vehicle. The Planning module may request a new routing computation if unable to follow the original route. [GitHub] Planning is subscribed to seven channels throughout the system; it is directly dependent on Dreamview, Routing, Localization, Prediction and Map. Localization The Localization module provides localization services to the platform. This module consists of three different Cyber components that each implement a different localization strategy on what sensors are available to the vehicle, the data from which it reads from channels of the Drivers module; providing an estimate of the vehicle's location as output. [GitHub] Map The Map module includes the HD Map found within our conceptual architecture, which served as a query engine for the other modules to provide detailed road information. [GitHub] The Map also includes a PnC Map and Relative Map. [GitHub] It is subscribed to Localization, Canbus, and Perception topics, and has code dependencies on Routing and Planning. Routing The Routing subsystem generates navigation paths, typically from the vehicle\u2019s current location to the passenger\u2019s destination. Another module can request for routing by publishing a RoutingRequest , which triggers the RoutingComponent (a child of cyber::Component ). Routing\u2019s logic additionally makes direct use of Map to produce a RoutingResponse which can be used by other modules, notably Planning. [GitHub] Canbus Acting as the interface between the software system and the physical chassis, Canbus works closely with the Control and Guardian modules, subscribing to and actualizing commands from one of them according to a configuration flag. Canbus also reports the chassis status to the rest of the system and relies heavily on code in Drivers in its operation. [GitHub] Storytelling The Storytelling subsystem is a scenario manager intended to coordinate inter-module actions. This module creates \u201cstories\u201d: complex scenarios that may be used by other modules. [GitHub] This sub-system does not subscribe to any module topics but does write to topics of its own; it is dependent directly on the Map module. Control The Control subsystem employs various algorithms to generate control commands for the steering, brakes, and throttle, depending on the scenario the vehicle is in. Control passes the commands to the Canbus to control the vehicle hardware. [GitHub] It is subscribed to topics from Planning and Canbus; it both subscribes to topics of and directly depends on Localization. Task Manager The Task Manager contains various routing managers to be employed by the system as required. It writes to a RoutingRequest channel if the routing process needs to be redone. [GitHub] It is subscribed to topics from the Routing and Localization modules and is directly dependent upon Dreamview and Map. Architectural Styles Recovering Apollo\u2019s concrete architecture confirmed that publish-subscribe served as the primary form of communication between modules; the method of how it is applied was described in detail previously in the Cyber RT subsystem description. The process-control pattern was confirmed in the concrete architecture, with the Control module acting as the controller, while Canbus acts as the process; here, the Control module creates execution plans, which the Canbus reads and actualizes for the hardware, then provides Chassis data (i.e., feedback) to Control. Finally, the client-server style of interaction via Cyber RT was confirmed; the Cyber RT API for Developers discusses the process in detail, in that it implements two-way communication in this fashion where a node sends a request to receive a response. [GitHub] The Routing channels RoutingResponse and RoutingRequest are one such example of this style. Reflexion Analysis Upon comparison between our conceptual publish-subscribe architecture and the concrete one, several discrepancies were identified in inter-module messaging dependencies. Table 1 describes the expected dependencies that were found to be absent in the concrete architecture. Table 2 describes the concrete dependencies that were not expected in the concrete architecture. Table 1: Conceptual dependencies absent in concrete architecture. Listener Module Talker Module Discrepancy Details Control Storytelling The expectation for Control having a dependency on Storytelling came from the Storytelling documentation listing Control as an example of a module that might subscribe to a story. At this time, there is only one story implemented in Storytelling, which does not require Control to be subscribed. Since any module could subscribe to Storytelling as more stories are implemented, this dependency might exist in the future. Routing Map This expected dependency is not necessarily absent, it instead takes a different form than initially expected. It was expected that communication between Routing and Map would be carried out over Cyber\u2019s publish-subscribe or client-server transports. Instead, it appears to be a direct code dependency. Storytelling Localization In 2020, this dependency was recorded in the README file for Storytelling ( 09a4f00 ); however, study of the code at this period of time reveals direct dependencies to Planning and Prediction that have been removed since, but not Localization either through code or messaging. Storytelling Map This expected dependency is not necessarily absent, it instead takes a different form than initially expected. It was expected that communication between Storytelling and Map would be carried out over Cyber\u2019s publish-subscribe or client-server transports. Instead, it appears to be a direct code dependency. Table 2: Dependencies found in concrete architecture not expected by conceptual. Listener Module Talker Module Discrepancy Details Drivers 1 Canbus The gnss::RawStream class of the GnssDriverComponent is subscribed to Chassis messages. On a timer, it extracts speed data from the message and writes a corresponding wheel velocity command to the command stream. Drivers 1 Localization The ContiRadarCanbusComponent is subscribed to LocalizationEstimate messages to extract the vehicle's pose data. Specifically, it uses orientation and linear velocity to calculate a speed and yaw rate, as required by the radar hardware. Guardian Canbus Guardian is subscribed to Chassis messages from Canbus so it can check for sonar faults and obstacles in the event of an emergency stop when safety mode is triggered. If either are found, the vehicle is supposed to make a hard emergency stop, otherwise a soft one can be made. However, since a change in June 2018, these flags are ignored pending \u201chardware re-alignment.\u201d ( 97b0b3c ) Guardian Control Guardian listens for ControlCommand messages from Control. When the system is not in safety mode, the ControlCommand s are wrapped in a GuardianCommand and published for Canbus to receive. When safety mode is enabled, the commands are blocked from reaching Canbus. Our assumption had been that the safety mode control logic existed in Canbus, which listened for commands from Control and a safety mode state from Guardian and considering both, rather than the commands passing through Guardian. Localization Drivers 1 The Localization module relies on sensor data from Drivers in the form of GnssBestPose , PointCloud , CorrectedImu , and InsStat messages. Map Canbus Chassis messages from Canbus are listened for by the RelativeMap submodule of the Map component. In part of creating the relative map, it uses Chassis and LocalizationEstimate data to update the vehicle state. Map Localization LocalizationEstimate messages from Localization are listened for by the RelativeMap submodule of the Map component. In part of creating the relative map, it uses Chassis and LocalizationEstimate data to update the vehicle state. Map Perception PerceptionObstacles messages from the Perception module that contain lane marker data are used by the RelativeMap submodule of the Map component to create one or more navigation paths in the relative map. Monitor Canbus Initial analysis during the development of the conceptual architecture concluded that Monitor\u2019s monitoring of other Apollo modules was primarily achieved by channel utilities provided by Cyber RT, and operations at the operating system level such as checking system resource usage and that processes are running. While those are all methods that Monitor employs, it also subscribes to topics of various modules to look out for anomalous activity. Control Dreamview Drivers 1 Localization Map Perception Planning Prediction Perception Drivers 1 The Perception module receives LiDAR and radar data in the form of PointCloud and ContiRadar messages, respectively, from the Drivers module. Planning Canbus Planning listens for Chassis messages containing details of the vehicle state. The chassis data is combined with data from the other subscribed inputs as a LocalView , which \u201ccontains all the necessary data as planning input.\u201d This input is not listed as a data input in the Planning documentation, so it was not considered in the conceptual architecture. Prediction Storytelling Prediction is subscribed to Stories messages from Storytelling, in order to be a part of cross-module coordination when a story scenario occurs. Prediction was not listed in the Storytelling documentation as an example subscriber, but any module could potentially be a story subscriber, depending on which stories have been implemented. The only story implemented so far is CloseToJunction , which requires Prediction. Task Manager 2 Localization The Task Manager listens for LocalizationEstimate messages, which it uses for vehicle positioning data. The vehicle coordinates are used to determine the distance to waypoints in cycle and dead-end routing tasks. Task Manager 2 Routing The Task Manager subscribes to RoutingResponse messages to confirm that routing requests that it has made have succeeded. Drivers had not been included in the conceptual architecture as a module, as such all publish-subscribe interactions involving it appear as a divergence. Task Manager had not been included in the conceptual architecture as a module, as such all publish-subscribe interactions involving it appear as a divergence. Code Dependencies Even in Apollo\u2019s publish-subscribe architecture, the modules and subsystems are not fully isolated or independent. One category of such code dependency makes complete sense, which is any dependency on the Common or Cyber modules. As described previously, these modules both provide utilities and runtime functionality, and are meant to be relied on in this way. Another category of inter-module code dependency comes from the use of protocol buffers. Every module that publishes messages includes .proto definitions that are used to generate protobuf serialization code at build time. Subscribing modules that need to deserialize the protobuf messages must rely on this generated code as well, which can be seen as #include s for files ending in .pb.h . This sort of dependency between modules is a requirement of the system, and the benefits of using strict schemas enforced by generated code at the expense of full module isolation far outweigh the benefits of full isolation but requiring either unstructured messages or duplicated message class code. However, one case where this is less expected is in the VehicleStateProvider class of the Common module, which depends on Chassis and LocalizationEstimate protobuf code from Canbus and Localization, respectively, as well as in the accompanying vehicle_state.proto which relies on chasis.proto and pose.proto from the same respective modules. It is unusual for a common module to depend on more specific functional modules, even in this way. Other code dependencies that were found are detailed in Table 3. Table 3: Other inter-module code dependencies. Dependent Module Dependency Module Dependency Details Canbus Drivers The Canbus module depends heavily on the Drivers module, specifically the drivers/canbus/ subdirectory. The drivers/canbus/ directory contains CAN client code, such as the base CanClient class, specific CAN client implementations that inherit from CanClient , and the CanClientFactory that registers the clients. The CAN client code used to be part of the Canbus module but was moved to drivers/ since different sensors using the protocol all share use of it. ( 10fb2bf ) Common Localization Common declares a dependency on the localization_gflags.h file in the implementation of the VehicleStateProvider class. The value of this flag is used to choose how to determine the linear acceleration and angular velocity of the vehicle. It is, however, quite odd to see a \u201ccommon\u201d module depend on a specific subsystem. Control Localization The LonController class in the Control module includes the localization_gflags.h file but does not appear to make use of the flags anywhere. The inclusion dates to Apollo 1.0 and the earliest commit in the codebase, but the flags go unused there and in every revision since. The dependency is unnecessary. Dreamview Map Dreamview\u2019s MapService makes use of both hdmap::PncMap and hdmap::HDMap (via hdmap::HDMapUtil ), querying both map models for routing information and road features such as lanes, speedbumps, signs, etc. Additional use of Map classes is used in simulation functionality. Map Planning The hdmap::PncMap class includes planning_gflags.h from the Planning module since December 2017. ( 4abd4e3 ) The class logic continues to make use of these flags. Map Routing At one time, the hdmap::PncMap class was made dependent on one of the flags from routing_gflags.h . ( 1effd0c ) However, the use of this flag was later modified, then removed entirely. ( b3ce40c ) No other Routing flags are used by this class, making the dependency unnecessary. Monitor Dreamview The MonitorManager class has a dependency on the dreamview::HMIWorker , which is a singleton object, as well as on dreamview_gflags.h . The HMIWorker singleton is used to update configs and monitored modules when the HMI status reports a mode change. Perception Map Perception contains the perception::map::HDMapInput class, which is a thread-safe singleton wrapping HDMap for use by the many subcomponents of Perception, including various sensors that need map data, and for sensor fusion. The wrapper includes hdmap.h , hdmap_common.h , and hdmap_util.h . Perception Prediction The Perception module\u2019s multi-LiDAR fusion engine and evaluator manager make use of classes from the Prediction module. The former using the obstacles and pose containers and the latter relying on the semantic LSTM evaluator. This appears to be a case of specialized code reuse for the evaluator use case and not a runtime module interaction. Planning Dreamview planning::OpenSpaceRoiDecider declares a dependency on dreamview::MapService , however it is unclear why. It does not appear to be used. It is possible that the dependency being unused, or the location of its use, is lost in the size of the commit it was introduced in. ( 6db2a1b ) Planning Map The Planning module makes significant use of elements of all three submodules of the Map system, relying on the HD Map, PnC Map, and relative map for road and environment details in navigation planning. Planning Prediction AutotuningMLPModel in Planning extends prediction::network::NetModel , which is a base class for implementing machine learning network models. This is a case of code reuse not module interaction at runtime, but the base class could be considered for extraction into a common library. Planning Routing The planning::ReferenceLineProvider class declares a dependency on routing_gflags.h from the Routing module, since the class logic relied on one of the flags. ( b3ce40c ) The method where the flag was used was later made unreachable, ( c488562 ) and the dead code was removed some time later. ( c0331f9 ) However, the dependency was not removed, despite now being unnecessary. Prediction Map The Prediction module makes use of HD Map as part of its prediction map and semantic map. The primary interaction appears to be positioning and predicting the movement of obstacles relative to lanes, with lane details coming from Map. Routing Map 1 The routing::Routing class declares a dependency on hdmap_util.h from the Map module. It uses a utility from there to get the routing map file to construct a Navigator , and another to receive a pointer to the HDMap object, which it uses to query lanes and parking spaces. Storytelling Map 1 The storytelling::CloseToJunctionTeller class makes use of the hdmap::HDMapUtil class querying details of the surroundings when approaching an intersection. Task Manager Dreamview task_manager::CycleRoutingManager uses a dependency on dreamview::MapService to construct lane waypoints when getting new routing at the beginning/end of a cycle. Task Manager Map Task Manager\u2019s DeadEndRoutingManager and ParkingRoutingManager declare several dependencies on HD Map classes but make no use of them. Like the earlier Planning/Dreamview dependency this was introduced in a very large, squashed commit and it seems likely that the unnecessary dependencies went unnoticed. ( 6db2a1b ) This dependency is notable since in the initial conceptual architecture analysis it was assumed that the communication was done either by the pub-sub channels or Cyber RT\u2019s client-server mechanism. However, it appears to simply be a code dependency. Subsystem: Prediction In studying the architecture of Apollo, we chose to study one of its core subsystems, the Prediction module, in further detail. This entailed deriving its conceptual architecture, and then forming its concrete architecture, applying the reflexion analysis in the process. Subcomponents Container The Container stores input data that the Prediction module listens for from subscribed topics; currently, these are Perception obstacles, Planning, and Localization. [GitHub] Scenario The Scenario sub-module defines scenarios that the ego vehicle may be in; currently these scenarios are cruising , which includes lane keeping and following, and junction , which includes intersections with traffic lights and/or stop signs. [GitHub] Evaluator The Evaluator separately predicts the path and speed of each obstacle and evaluates them by outputting a probability that they occur by using a given model. It uses a variety of possible evaluators, and most apply machine learning to determine these probabilities; the models utilized in these machine learning evaluators include RNN, MLP, CNN-1d and social LSTM. For example, the Semantic LSTM Evaluator, used for \u201ccaution\u201d-level obstacles, generates short-term trajectory points via CNN and LSTM. [GitHub] Predictor The Predictor generates predicted trajectories. A variety of possible predictors are supported, including empty , for obstacles with no predicted trajectories; single lane , where they move along a single lane in \u201chighway navigation mode;\u201d lane sequence , where they move along the lanes; move sequence , moving along the lanes \u201cfollowing its kinetic pattern;\u201d free movement ; regional movement , moving in a possible region; and junction , moving toward junction exits. An interpolation predictor computes the likelihood of creating posterior prediction results after all evaluators have run, intended for \u201ccaution\u201d-level obstacles. An extrapolation predictor creates an 8 sec trajectory, extending the Semantic LSTM Evaluator. [GitHub] Conceptual Architecture To derive the conceptual architecture of the Prediction module, we studied its documentation. The documentation, found in the module README file, provided details on each core sub-module, as well as a diagram presenting their communication and control flow. Figure 7: Conceptual architecture of the Prediction module. Concrete Architecture As with the concrete architecture of the full system, we studied the dependency diagram formulated by Understand to derive specific dependencies of the system. This, however, has limitations regarding publish-subscribe communication between Prediction\u2019s sub-modules and other modules in the system, as the provided publish-subscribe visualization does not go into such detail. However, a study of the main sub-modules\u2019 code presents that the Evaluator and Predictor modules have publish-subscribe dependencies to other modules. Figure 8: Concrete architecture for the Prediction module. Figure 9: Publish-subscribe communication focused on the Prediction module. Architectural Styles The visual representation of the subcomponent communication reviewed in the conceptual architecture derivation process led us to conclude that the object-oriented style would fit the architecture. This is as the sub-modules would need to know the identities of one another. The Container identifies and protects specific input data; the other sub-modules may use these specific data, i.e., they need to know which data is which, and from which source it is from. This is supported by direct includes in the code to specific Containers in the concrete architecture. In addition to the object-oriented style, Prediction employs some publish-subscribe communication, both in terms of inter-module and intra-module communication. In particular, the Evaluator and Predictor listen for specific topics, which can be seen in their submodule code. Reflexion Analysis Many major discrepancies from conceptual to concrete architecture of the Prediction module are the addition of new sub-modules. These include Submodule Output, Util (Data Extraction), Network, Pipeline (Vector Net), Prediction Common, and the Core/Main Files modules. It was expected that the Vector Net would have been stored within the Evaluator; the Core/Main Files \u201cmodule\u201d serves as the main form of reading publish-subscribe messages, as well as writing final Prediction output. Thus, any dependencies to or from these modules were unexpected. There were two dependencies between sub-modules that were seemingly absent in the concrete architecture. The first was the dependency from Predictor to Evaluator; this was displayed as a direct sequential flow in the visualization within the README. However, comments in the Predictor sub-module suggest that this dependency exists, but instead in a publish-subscribe communication format. [GitHub] The other discrepancy was the dependency from Evaluator to Scenario; as with the other dependency, this was expected due to the README, but was missing. As Evaluator largely uses machine learning in its implementation, generating various paths and corresponding probabilities, the scenario may not be as relevant. Inter-module publish-subscribe topics were expected to be read by the Container, as it stores their input data; however, this is absent in the concrete architecture. Instead, these topics are read by the Prediction component\u2019s Core/Main Files. This module also publishes to the ADCTrajectoryContainer and SubmoduleOutput used by the Evaluator and Predictor. The Container, included in the Main Files, processes the received data from the main Prediction component file via ContainerSubmoduleProcess , rather than receiving it itself. Finally, various unanticipated direct dependencies from the sub-modules to other modules may be found. All four original modules depend on the Common module; the Evaluator and Predictor are Cyber RT components. The Container directly includes the Map, by including the hdmap_common.h file for its obstacles and obstacle clusters. Use Cases Use Case 1: Lane Following Figure 10: Sequence diagram for the lane following use case, in accordance with the concrete architecture. In this first use case of lane following, the vehicle stays within a lane while following another car at a safe distance. The diagram in Figure 10 highlights the flow of publish-subscribe channel data. First, the Perception module reads subscribed Drivers messages, which it processes; using the LocalizationEstimate , as well as more sensor data, it determines the perceived obstacles and traffic light status, if applicable. Using published Stories , LocalizationEstimate , PerceptionObstacles , and the ADCTrajectory of the previous cycle, the Prediction module predicts trajectories for the obstacles. The Planning module then plans a trajectory using the PredictionObstacles , TrafficLightDetection , Stories , LocalizationEstimate , MapMsg , RoutingResponse , and Chassis ; it publishes the trajectory to the ADCTrajectory channel. This is used by the Control module, in addition to the Chassis and LocalizationEstimate , to create control commands. The Canbus then reads the ControlCommand to send them to the hardware. Use Case 2: Unprotected Left Turn Figure 11: Sequence diagram for the Unprotected Left Turn use case, centered upon the Planning component. Use Case 2 is the Unprotected Left Turn scenario. In this scenario, the vehicle is to turn left at an intersection with a traffic light; \u201cunprotected\u201d refers to how the traffic light is not using specific turn lights (i.e., left-only). Figure 11 presents a sequence diagram for this use case, which was created after a study of the Planning component code. After the Planning component reads messages from Localization, Storytelling, Prediction, Routing, Canbus, Map, Perception, and itself, it runs various planners once to plan trajectories. These planners use a Scenario Manager, creating the scenario as well as its current stage (Approach if not yet at the intersection, Creep to move forward and survey, and Intersection Cruise to move through). Tasks are found in a Task Factory, including deciding on the speed and path. Once this is complete, the stage, and then scenario, is finished; the Planners generate the trajectory using trajectory generators, and the optimal trajectory is written to the ADCTrajectory topic. [GitHub] Lessons Learned Certain unexpected things complicated the architecture derivation process. Firstly, Understand is unable to detect protobuf dependencies, which means some module dependencies are obscured since they occur in code generated from the protobuf files. Second, the Apollo developers do not write very descriptive commit messages, and most pull requests that were looked at as being relevant to our investigation had no description. Apollo, being a large system, has various modules that are regularly updated over time, and the documentation is not necessarily updated with it; in addition, it may be simplified to the true state of the system for readability purposes or complexity. Glossary HMI: Human Machine Interface LiDAR: Light Detection and Ranging Conti radar: A radar sensor from Continental Engineering. Specifically, Apollo uses the Continental ARS-408-21 Radar package. PnC: Planning and Control CAN: Controller Area Network. A host-less messaging bus protocol primarily used with microcontrollers in automotive contexts. References ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed March 21, 2022. Retrieved from https://github.com/ApolloAuto/apollo. ApolloAuto. \u201cPlanning README at 5.5.0.\u201d GitHub (2020). Retrieved from https://github.com/ApolloAuto/apollo/blob/r5.5.0/modules/planning/README.md. Behere, Sagar, and Martin T\u00f6rngren. \u201cA functional reference architecture for autonomous driving.\u201d KTH The Royal Institute of Technology, Brinellv\u00e4gen 83, Stockholm SE-10044, Sweden (2015): 143. Retrieved from https://www.sciencedirect.com/science/article/abs/pii/S0950584915002177. OBEIA. \u201cThe Conceptual Architecture of Apollo.\u201d February 20, 2022. Retrieved from https://obeia.github.io/assignment1/.","title":"Concrete Architecture"},{"location":"assignment2/#the-concrete-architecture-of-apollo","text":"Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.)","title":"The Concrete Architecture of Apollo"},{"location":"assignment2/#abstract","text":"As an open-source autonomous driving platform, Apollo understandably is a complex system. Having developed greatly over the years, its architecture has changed over time; thus, its concrete architecture may vary from the conceptual architecture derived from its documentation. To derive the concrete architecture, the Understand 5.1 tool, GitHub repository, and a publish-subscribe communication visualization diagram were utilized to determine dependencies between modules. This process confirmed the publish-subscribe, process-control, and client-server architectural styles determined in the conceptual architecture, but also added three new modules\u2014Drivers, Common, and Task Manager\u2014as well as updated the Map module; various discrepancies were found in the Reflexion Analysis process, including direct code dependencies. The Prediction submodule was also studied in this process, revealing that this module utilizes a combination of the object-oriented and publish-subscribe styles in its predicting of obstacle trajectories, with four core sub-modules: Container, Scenario, Evaluator and Predictor.","title":"Abstract"},{"location":"assignment2/#introduction","text":"Apollo is an open-source platform dedicated to the development and testing of autonomously driving vehicles. As a system that values security and safety while maintaining good performance, Apollo\u2019s developers have created a complex system that largely uses the publish-subscribe style. The system contains a variety of subsystems that provide its functionality while satisfying its requirements, including a Perception module to determine obstacles and details, a Prediction module to predict how the surrounding world and obstacles may change, a Planning module that plans the vehicle\u2019s trajectory, and a Control module that transforms the trajectory into commands for the vehicle to deploy. A conceptual architecture was created by studying a reference architecture [Behere and T\u00f6rngren] as well as utilizing Apollo\u2019s documentation. Although the conceptual architecture may describe the system of Apollo to a degree, there are always limitations to what may be extracted via a reference architecture or system documentation. It may deviate from the reference architecture; the documentation may be a work in progress for the system\u2019s current state, and/or omit minor dependencies. Thus, to fully understand Apollo, one must study its code to determine its concrete architecture. To derive the concrete architectures of both Apollo as a whole and our chosen subsystem, Prediction, we used the Understand tool at version 5.1, as well as a graph visualization of the publish-subscribe communication within the system, and in-depth investigation of the source code. Dependencies found within these visualizations were compared to our conceptual architecture, and discrepancies were added or removed as necessary. These discrepancies were studied in further detail to understand them in various ways, including their purpose and timing. Studying Apollo\u2019s source code reveals three additional modules: Drivers, Task Manager and Common, as well as a module, Map, which contains a component of our conceptual architecture, HD Map, as a sub-component. In addition, although publish-subscribe remains largely what the system is built on, Apollo utilizes direct dependencies in its functionality, particularly to the Map module as well as a Common module, and various calls to include files from different components that help in other components\u2019 function.","title":"Introduction"},{"location":"assignment2/#derivation-process","text":"Figures 1 and 2 visualize the conceptual architecture that was derived from Apollo documentation and the reference architecture. Figure 1 highlights the dependency relations between various modules, while Figure 2 emphasizes the architectural style that Apollo is largely built upon: the publish-subscribe style, where modules publish and subscribe to topics of interest as their main form of communication with one another. Figure 1: Dependency relations of the Apollo architecture, as determined in the conceptual architecture retrieval process. (Corrected to match conceptual architecture report text.) Figure 2: Communication flow within the Apollo conceptual architecture. The conceptual architecture retrieved from various Apollo- and autonomous driving-related sources is an essential aspect of determining and understanding the concrete architecture used by the system. The process of deriving this conceptual architecture, as well as its details, may be found in our previous report. [OBEIA]","title":"Derivation Process"},{"location":"assignment2/#understand-publish-subscribe-and-reflection","text":"One way to derive the concrete architecture of a system is by studying its source code, taking note of when modules and files within them reference other modules, suggesting a dependency. One method of doing so is via the Understand program. Using a file for this program provided by our instructor, we applied Understand 5.1\u2019s dependency diagram tool; this process produces a visual of the dependencies of the system and allows one to view their specifics. However, due to the publish-subscribe style relying upon a central bus, many dependencies are obscured. To mediate this, our instructor provided another diagram, shown in Figure 3, representing the communication between modules in this style. Using these diagrams, we regularly considered our conceptual architecture, adding and removing dependencies as necessary; in considering these dependencies within Understand, we removed test files that did not affect the system itself. When reviewing discrepancies, we also discerned their purpose, timing, and attribution, if applicable, provided in Reflexion Analysis. In our study of the source code, three new modules or sub-components were found: a common module, a task manager, and drivers. Further, rather than HD Map, there is a \u201cMap\u201d module containing the HD Map as a sub-component. These modules are described in further detail with other subsystems of Apollo, within the Concrete Architecture section. The dependency diagrams and publish-subscribe visualization highlight many different dependencies through the system, notably various dependencies that do not occur within the publish-subscribe communication flow. Some dependencies recorded in our conceptual architecture were missing, whereas many unanticipated dependencies were found. Figure 3: Publish-subscribe communication visualization within Apollo.","title":"Understand, Publish-Subscribe and Reflection"},{"location":"assignment2/#concrete-architecture","text":"Figures 4 and 5 present the concrete architecture of Apollo\u2019s software system as code dependencies, Figure 6 presents the architecture as messaging dependencies between modules. The architecture and interactions are described further in the following sub-sections. Figure 4: Apollo system inter-module code dependencies, according to Understand 5.1. Figure 5: Simplified view of Apollo inter-module dependencies. Figure 6: Publish-subscribe communication of the concrete Apollo architecture.","title":"Concrete Architecture"},{"location":"assignment2/#modules-and-subsystems","text":"","title":"Modules and Subsystems"},{"location":"assignment2/#cyber-rt","text":"Apollo\u2019s architecture is built around a custom runtime framework called Cyber RT . Cyber RT has many responsibilities as both a runtime component and a base library for other system modules. At runtime, Cyber manages module loading and most of the inter- and even intra-module communication, through facilities for either publish-subscribe messaging or client-server interaction. Cyber RT also provides code dependencies, including runtime base classes, and utilities for file operations, logging, timing, concurrency, and asynchrony. The publish-subscribe functionality is done through a \u201cchannel\u201d abstraction over multiple transport types, allowing it to be suited for various deployment scenarios. The cyber::Reader class template allows construction of subscribers to a channel and to receive messages on it, either declaring a callback function to trigger when a message is received or allowing messages to be cached for later observation. In many cases, the callback function is simply to store the message so a reference to the latest one is available for use. Publishing to a channel is handled by specializations of the cyber::Writer class template, which can write a single message type to a single channel. On the wire, exchanged messages are byte streams in the protocol buffer (protobuf) encoding format. Each module includes a collection of .proto files which define the messages it sends. Code is generated from the .proto files at build time, which is used by the publishing module for message serialization, and by the subscribing module(s) for deserialization. The Apollo runtime modules are made up of one or more Cyber RT \u201ccomponents\u201d. There are two component base classes that a module can inherit from: cyber::Component (and its various partial specializations) and cyber::TimerComponent . Components inheriting from cyber::Component can declare zero to four message types to listen for and have their main processing logic automatically triggered when a message is received on those channels. Components inheriting from cyber::TimerComponent are instead triggered on certain time intervals. Either type of component can declare additional Reader s, and as many Writer s as required. All components must be registered with Cyber RT to operate. The fundamental nature of Cyber RT means that all other operating subsystems of Apollo depend on it.","title":"Cyber RT"},{"location":"assignment2/#common","text":"While not a running module that provides specific functionality to the system, the Common module contains useful code that other modules may rely on. The contents include global constants (in the form of gflags ) for topic names, vehicle configuration and data, access to system-wide parameters through a key-value database, latency recording and monitor logging, operation statuses, protocol buffer definitions that see use across the entire system, various math and parsing utilities, and a class that models the overall vehicle state, among others. [GitHub] As it is not a runtime module, Common does not exist as a Cyber RT component. Other than Cyber RT, every analyzed Apollo subsystem relies on Common.","title":"Common"},{"location":"assignment2/#drivers","text":"The Drivers module contains code for interfacing with the various hardware components of the Apollo vehicle platform. It contains CAN client code, used both for reading from typical chassis sensors and controlling the vehicle. Additionally, it contains interfaces for the more advanced sensing equipment required for autonomous vehicle operation, including cameras, microphones, LiDAR, radar, and GNSS. These sensors are bridged into the rest of the system by Cyber RT components that write their readings to channels for other modules to read. Some Drivers components are subscribed to messages from the Localization and Canbus modules, relying on them for operational information.","title":"Drivers"},{"location":"assignment2/#guardian","text":"Guardian acts as Apollo\u2019s emergency response system, implemented as a Cyber RT TimerComponent . All messages from Control to Canbus pass through Guardian, which decides whether to block them based on vehicle and system status it receives from Canbus and Monitor. In the event of a system error, Control commands will be blocked, and Guardian will instead direct Canbus to bring the vehicle to a stop.","title":"Guardian"},{"location":"assignment2/#monitor","text":"Monitor is a cyber::TimerComponent that regularly checks the status of the hardware and software of the system, using various mechanisms including OS-level process checks, and status messages on most Cyber RT channels. It reports results on the SystemStatus channel and is also able to directly update Dreamview.","title":"Monitor"},{"location":"assignment2/#dreamview","text":"Apollo\u2019s HMI module, Dreamview , includes a JavaScript frontend that allows users to visualize the data produced by other subsystems, and an on-board backend. Dreamview reads messages from all other modules and produces a three-dimensional representation of the vehicle including the current location and planned path and displays the status of the system components and hardware. Additionally, Dreamview contains a map service that other modules rely on, and an interface to allow certain HMI actions to be carried out.","title":"Dreamview"},{"location":"assignment2/#perception","text":"The Perception subsystem takes input from physical sensors mounted on a vehicle, including cameras, LiDAR sensors, and radar, over channels from the Drivers module. This subsystem outputs decisions on the state of nearby traffic lights and a list of objects which are labelled with their type, distance from the vehicle, and velocity. [GitHub] The module is quite complex and includes ten different Cyber RT components.","title":"Perception"},{"location":"assignment2/#prediction","text":"The Prediction subsystem predicts the future movements of objects identified by the perception module, implemented as a cyber::Component that is triggered by the publishing of PerceptionObstacles messages. [GitHub] This module is described in more detail in the Subsystem: Prediction section of this report. In addition to Perception, the module reads from Storytelling, Map, and Localization subsystem channels.","title":"Prediction"},{"location":"assignment2/#planning","text":"The Planning subsystem aims to plan the exact route of the vehicle. It first plans short term goals such as staying in a lane, then plans the future trajectory of the vehicle. The Planning module may request a new routing computation if unable to follow the original route. [GitHub] Planning is subscribed to seven channels throughout the system; it is directly dependent on Dreamview, Routing, Localization, Prediction and Map.","title":"Planning"},{"location":"assignment2/#localization","text":"The Localization module provides localization services to the platform. This module consists of three different Cyber components that each implement a different localization strategy on what sensors are available to the vehicle, the data from which it reads from channels of the Drivers module; providing an estimate of the vehicle's location as output. [GitHub]","title":"Localization"},{"location":"assignment2/#map","text":"The Map module includes the HD Map found within our conceptual architecture, which served as a query engine for the other modules to provide detailed road information. [GitHub] The Map also includes a PnC Map and Relative Map. [GitHub] It is subscribed to Localization, Canbus, and Perception topics, and has code dependencies on Routing and Planning.","title":"Map"},{"location":"assignment2/#routing","text":"The Routing subsystem generates navigation paths, typically from the vehicle\u2019s current location to the passenger\u2019s destination. Another module can request for routing by publishing a RoutingRequest , which triggers the RoutingComponent (a child of cyber::Component ). Routing\u2019s logic additionally makes direct use of Map to produce a RoutingResponse which can be used by other modules, notably Planning. [GitHub]","title":"Routing"},{"location":"assignment2/#canbus","text":"Acting as the interface between the software system and the physical chassis, Canbus works closely with the Control and Guardian modules, subscribing to and actualizing commands from one of them according to a configuration flag. Canbus also reports the chassis status to the rest of the system and relies heavily on code in Drivers in its operation. [GitHub]","title":"Canbus"},{"location":"assignment2/#storytelling","text":"The Storytelling subsystem is a scenario manager intended to coordinate inter-module actions. This module creates \u201cstories\u201d: complex scenarios that may be used by other modules. [GitHub] This sub-system does not subscribe to any module topics but does write to topics of its own; it is dependent directly on the Map module.","title":"Storytelling"},{"location":"assignment2/#control","text":"The Control subsystem employs various algorithms to generate control commands for the steering, brakes, and throttle, depending on the scenario the vehicle is in. Control passes the commands to the Canbus to control the vehicle hardware. [GitHub] It is subscribed to topics from Planning and Canbus; it both subscribes to topics of and directly depends on Localization.","title":"Control"},{"location":"assignment2/#task-manager","text":"The Task Manager contains various routing managers to be employed by the system as required. It writes to a RoutingRequest channel if the routing process needs to be redone. [GitHub] It is subscribed to topics from the Routing and Localization modules and is directly dependent upon Dreamview and Map.","title":"Task Manager"},{"location":"assignment2/#architectural-styles","text":"Recovering Apollo\u2019s concrete architecture confirmed that publish-subscribe served as the primary form of communication between modules; the method of how it is applied was described in detail previously in the Cyber RT subsystem description. The process-control pattern was confirmed in the concrete architecture, with the Control module acting as the controller, while Canbus acts as the process; here, the Control module creates execution plans, which the Canbus reads and actualizes for the hardware, then provides Chassis data (i.e., feedback) to Control. Finally, the client-server style of interaction via Cyber RT was confirmed; the Cyber RT API for Developers discusses the process in detail, in that it implements two-way communication in this fashion where a node sends a request to receive a response. [GitHub] The Routing channels RoutingResponse and RoutingRequest are one such example of this style.","title":"Architectural Styles"},{"location":"assignment2/#reflexion-analysis","text":"Upon comparison between our conceptual publish-subscribe architecture and the concrete one, several discrepancies were identified in inter-module messaging dependencies. Table 1 describes the expected dependencies that were found to be absent in the concrete architecture. Table 2 describes the concrete dependencies that were not expected in the concrete architecture. Table 1: Conceptual dependencies absent in concrete architecture. Listener Module Talker Module Discrepancy Details Control Storytelling The expectation for Control having a dependency on Storytelling came from the Storytelling documentation listing Control as an example of a module that might subscribe to a story. At this time, there is only one story implemented in Storytelling, which does not require Control to be subscribed. Since any module could subscribe to Storytelling as more stories are implemented, this dependency might exist in the future. Routing Map This expected dependency is not necessarily absent, it instead takes a different form than initially expected. It was expected that communication between Routing and Map would be carried out over Cyber\u2019s publish-subscribe or client-server transports. Instead, it appears to be a direct code dependency. Storytelling Localization In 2020, this dependency was recorded in the README file for Storytelling ( 09a4f00 ); however, study of the code at this period of time reveals direct dependencies to Planning and Prediction that have been removed since, but not Localization either through code or messaging. Storytelling Map This expected dependency is not necessarily absent, it instead takes a different form than initially expected. It was expected that communication between Storytelling and Map would be carried out over Cyber\u2019s publish-subscribe or client-server transports. Instead, it appears to be a direct code dependency. Table 2: Dependencies found in concrete architecture not expected by conceptual. Listener Module Talker Module Discrepancy Details Drivers 1 Canbus The gnss::RawStream class of the GnssDriverComponent is subscribed to Chassis messages. On a timer, it extracts speed data from the message and writes a corresponding wheel velocity command to the command stream. Drivers 1 Localization The ContiRadarCanbusComponent is subscribed to LocalizationEstimate messages to extract the vehicle's pose data. Specifically, it uses orientation and linear velocity to calculate a speed and yaw rate, as required by the radar hardware. Guardian Canbus Guardian is subscribed to Chassis messages from Canbus so it can check for sonar faults and obstacles in the event of an emergency stop when safety mode is triggered. If either are found, the vehicle is supposed to make a hard emergency stop, otherwise a soft one can be made. However, since a change in June 2018, these flags are ignored pending \u201chardware re-alignment.\u201d ( 97b0b3c ) Guardian Control Guardian listens for ControlCommand messages from Control. When the system is not in safety mode, the ControlCommand s are wrapped in a GuardianCommand and published for Canbus to receive. When safety mode is enabled, the commands are blocked from reaching Canbus. Our assumption had been that the safety mode control logic existed in Canbus, which listened for commands from Control and a safety mode state from Guardian and considering both, rather than the commands passing through Guardian. Localization Drivers 1 The Localization module relies on sensor data from Drivers in the form of GnssBestPose , PointCloud , CorrectedImu , and InsStat messages. Map Canbus Chassis messages from Canbus are listened for by the RelativeMap submodule of the Map component. In part of creating the relative map, it uses Chassis and LocalizationEstimate data to update the vehicle state. Map Localization LocalizationEstimate messages from Localization are listened for by the RelativeMap submodule of the Map component. In part of creating the relative map, it uses Chassis and LocalizationEstimate data to update the vehicle state. Map Perception PerceptionObstacles messages from the Perception module that contain lane marker data are used by the RelativeMap submodule of the Map component to create one or more navigation paths in the relative map. Monitor Canbus Initial analysis during the development of the conceptual architecture concluded that Monitor\u2019s monitoring of other Apollo modules was primarily achieved by channel utilities provided by Cyber RT, and operations at the operating system level such as checking system resource usage and that processes are running. While those are all methods that Monitor employs, it also subscribes to topics of various modules to look out for anomalous activity. Control Dreamview Drivers 1 Localization Map Perception Planning Prediction Perception Drivers 1 The Perception module receives LiDAR and radar data in the form of PointCloud and ContiRadar messages, respectively, from the Drivers module. Planning Canbus Planning listens for Chassis messages containing details of the vehicle state. The chassis data is combined with data from the other subscribed inputs as a LocalView , which \u201ccontains all the necessary data as planning input.\u201d This input is not listed as a data input in the Planning documentation, so it was not considered in the conceptual architecture. Prediction Storytelling Prediction is subscribed to Stories messages from Storytelling, in order to be a part of cross-module coordination when a story scenario occurs. Prediction was not listed in the Storytelling documentation as an example subscriber, but any module could potentially be a story subscriber, depending on which stories have been implemented. The only story implemented so far is CloseToJunction , which requires Prediction. Task Manager 2 Localization The Task Manager listens for LocalizationEstimate messages, which it uses for vehicle positioning data. The vehicle coordinates are used to determine the distance to waypoints in cycle and dead-end routing tasks. Task Manager 2 Routing The Task Manager subscribes to RoutingResponse messages to confirm that routing requests that it has made have succeeded. Drivers had not been included in the conceptual architecture as a module, as such all publish-subscribe interactions involving it appear as a divergence. Task Manager had not been included in the conceptual architecture as a module, as such all publish-subscribe interactions involving it appear as a divergence.","title":"Reflexion Analysis"},{"location":"assignment2/#code-dependencies","text":"Even in Apollo\u2019s publish-subscribe architecture, the modules and subsystems are not fully isolated or independent. One category of such code dependency makes complete sense, which is any dependency on the Common or Cyber modules. As described previously, these modules both provide utilities and runtime functionality, and are meant to be relied on in this way. Another category of inter-module code dependency comes from the use of protocol buffers. Every module that publishes messages includes .proto definitions that are used to generate protobuf serialization code at build time. Subscribing modules that need to deserialize the protobuf messages must rely on this generated code as well, which can be seen as #include s for files ending in .pb.h . This sort of dependency between modules is a requirement of the system, and the benefits of using strict schemas enforced by generated code at the expense of full module isolation far outweigh the benefits of full isolation but requiring either unstructured messages or duplicated message class code. However, one case where this is less expected is in the VehicleStateProvider class of the Common module, which depends on Chassis and LocalizationEstimate protobuf code from Canbus and Localization, respectively, as well as in the accompanying vehicle_state.proto which relies on chasis.proto and pose.proto from the same respective modules. It is unusual for a common module to depend on more specific functional modules, even in this way. Other code dependencies that were found are detailed in Table 3. Table 3: Other inter-module code dependencies. Dependent Module Dependency Module Dependency Details Canbus Drivers The Canbus module depends heavily on the Drivers module, specifically the drivers/canbus/ subdirectory. The drivers/canbus/ directory contains CAN client code, such as the base CanClient class, specific CAN client implementations that inherit from CanClient , and the CanClientFactory that registers the clients. The CAN client code used to be part of the Canbus module but was moved to drivers/ since different sensors using the protocol all share use of it. ( 10fb2bf ) Common Localization Common declares a dependency on the localization_gflags.h file in the implementation of the VehicleStateProvider class. The value of this flag is used to choose how to determine the linear acceleration and angular velocity of the vehicle. It is, however, quite odd to see a \u201ccommon\u201d module depend on a specific subsystem. Control Localization The LonController class in the Control module includes the localization_gflags.h file but does not appear to make use of the flags anywhere. The inclusion dates to Apollo 1.0 and the earliest commit in the codebase, but the flags go unused there and in every revision since. The dependency is unnecessary. Dreamview Map Dreamview\u2019s MapService makes use of both hdmap::PncMap and hdmap::HDMap (via hdmap::HDMapUtil ), querying both map models for routing information and road features such as lanes, speedbumps, signs, etc. Additional use of Map classes is used in simulation functionality. Map Planning The hdmap::PncMap class includes planning_gflags.h from the Planning module since December 2017. ( 4abd4e3 ) The class logic continues to make use of these flags. Map Routing At one time, the hdmap::PncMap class was made dependent on one of the flags from routing_gflags.h . ( 1effd0c ) However, the use of this flag was later modified, then removed entirely. ( b3ce40c ) No other Routing flags are used by this class, making the dependency unnecessary. Monitor Dreamview The MonitorManager class has a dependency on the dreamview::HMIWorker , which is a singleton object, as well as on dreamview_gflags.h . The HMIWorker singleton is used to update configs and monitored modules when the HMI status reports a mode change. Perception Map Perception contains the perception::map::HDMapInput class, which is a thread-safe singleton wrapping HDMap for use by the many subcomponents of Perception, including various sensors that need map data, and for sensor fusion. The wrapper includes hdmap.h , hdmap_common.h , and hdmap_util.h . Perception Prediction The Perception module\u2019s multi-LiDAR fusion engine and evaluator manager make use of classes from the Prediction module. The former using the obstacles and pose containers and the latter relying on the semantic LSTM evaluator. This appears to be a case of specialized code reuse for the evaluator use case and not a runtime module interaction. Planning Dreamview planning::OpenSpaceRoiDecider declares a dependency on dreamview::MapService , however it is unclear why. It does not appear to be used. It is possible that the dependency being unused, or the location of its use, is lost in the size of the commit it was introduced in. ( 6db2a1b ) Planning Map The Planning module makes significant use of elements of all three submodules of the Map system, relying on the HD Map, PnC Map, and relative map for road and environment details in navigation planning. Planning Prediction AutotuningMLPModel in Planning extends prediction::network::NetModel , which is a base class for implementing machine learning network models. This is a case of code reuse not module interaction at runtime, but the base class could be considered for extraction into a common library. Planning Routing The planning::ReferenceLineProvider class declares a dependency on routing_gflags.h from the Routing module, since the class logic relied on one of the flags. ( b3ce40c ) The method where the flag was used was later made unreachable, ( c488562 ) and the dead code was removed some time later. ( c0331f9 ) However, the dependency was not removed, despite now being unnecessary. Prediction Map The Prediction module makes use of HD Map as part of its prediction map and semantic map. The primary interaction appears to be positioning and predicting the movement of obstacles relative to lanes, with lane details coming from Map. Routing Map 1 The routing::Routing class declares a dependency on hdmap_util.h from the Map module. It uses a utility from there to get the routing map file to construct a Navigator , and another to receive a pointer to the HDMap object, which it uses to query lanes and parking spaces. Storytelling Map 1 The storytelling::CloseToJunctionTeller class makes use of the hdmap::HDMapUtil class querying details of the surroundings when approaching an intersection. Task Manager Dreamview task_manager::CycleRoutingManager uses a dependency on dreamview::MapService to construct lane waypoints when getting new routing at the beginning/end of a cycle. Task Manager Map Task Manager\u2019s DeadEndRoutingManager and ParkingRoutingManager declare several dependencies on HD Map classes but make no use of them. Like the earlier Planning/Dreamview dependency this was introduced in a very large, squashed commit and it seems likely that the unnecessary dependencies went unnoticed. ( 6db2a1b ) This dependency is notable since in the initial conceptual architecture analysis it was assumed that the communication was done either by the pub-sub channels or Cyber RT\u2019s client-server mechanism. However, it appears to simply be a code dependency.","title":"Code Dependencies"},{"location":"assignment2/#subsystem-prediction","text":"In studying the architecture of Apollo, we chose to study one of its core subsystems, the Prediction module, in further detail. This entailed deriving its conceptual architecture, and then forming its concrete architecture, applying the reflexion analysis in the process.","title":"Subsystem: Prediction"},{"location":"assignment2/#subcomponents","text":"","title":"Subcomponents"},{"location":"assignment2/#container","text":"The Container stores input data that the Prediction module listens for from subscribed topics; currently, these are Perception obstacles, Planning, and Localization. [GitHub]","title":"Container"},{"location":"assignment2/#scenario","text":"The Scenario sub-module defines scenarios that the ego vehicle may be in; currently these scenarios are cruising , which includes lane keeping and following, and junction , which includes intersections with traffic lights and/or stop signs. [GitHub]","title":"Scenario"},{"location":"assignment2/#evaluator","text":"The Evaluator separately predicts the path and speed of each obstacle and evaluates them by outputting a probability that they occur by using a given model. It uses a variety of possible evaluators, and most apply machine learning to determine these probabilities; the models utilized in these machine learning evaluators include RNN, MLP, CNN-1d and social LSTM. For example, the Semantic LSTM Evaluator, used for \u201ccaution\u201d-level obstacles, generates short-term trajectory points via CNN and LSTM. [GitHub]","title":"Evaluator"},{"location":"assignment2/#predictor","text":"The Predictor generates predicted trajectories. A variety of possible predictors are supported, including empty , for obstacles with no predicted trajectories; single lane , where they move along a single lane in \u201chighway navigation mode;\u201d lane sequence , where they move along the lanes; move sequence , moving along the lanes \u201cfollowing its kinetic pattern;\u201d free movement ; regional movement , moving in a possible region; and junction , moving toward junction exits. An interpolation predictor computes the likelihood of creating posterior prediction results after all evaluators have run, intended for \u201ccaution\u201d-level obstacles. An extrapolation predictor creates an 8 sec trajectory, extending the Semantic LSTM Evaluator. [GitHub]","title":"Predictor"},{"location":"assignment2/#conceptual-architecture","text":"To derive the conceptual architecture of the Prediction module, we studied its documentation. The documentation, found in the module README file, provided details on each core sub-module, as well as a diagram presenting their communication and control flow. Figure 7: Conceptual architecture of the Prediction module.","title":"Conceptual Architecture"},{"location":"assignment2/#concrete-architecture_1","text":"As with the concrete architecture of the full system, we studied the dependency diagram formulated by Understand to derive specific dependencies of the system. This, however, has limitations regarding publish-subscribe communication between Prediction\u2019s sub-modules and other modules in the system, as the provided publish-subscribe visualization does not go into such detail. However, a study of the main sub-modules\u2019 code presents that the Evaluator and Predictor modules have publish-subscribe dependencies to other modules. Figure 8: Concrete architecture for the Prediction module. Figure 9: Publish-subscribe communication focused on the Prediction module.","title":"Concrete Architecture"},{"location":"assignment2/#architectural-styles_1","text":"The visual representation of the subcomponent communication reviewed in the conceptual architecture derivation process led us to conclude that the object-oriented style would fit the architecture. This is as the sub-modules would need to know the identities of one another. The Container identifies and protects specific input data; the other sub-modules may use these specific data, i.e., they need to know which data is which, and from which source it is from. This is supported by direct includes in the code to specific Containers in the concrete architecture. In addition to the object-oriented style, Prediction employs some publish-subscribe communication, both in terms of inter-module and intra-module communication. In particular, the Evaluator and Predictor listen for specific topics, which can be seen in their submodule code.","title":"Architectural Styles"},{"location":"assignment2/#reflexion-analysis_1","text":"Many major discrepancies from conceptual to concrete architecture of the Prediction module are the addition of new sub-modules. These include Submodule Output, Util (Data Extraction), Network, Pipeline (Vector Net), Prediction Common, and the Core/Main Files modules. It was expected that the Vector Net would have been stored within the Evaluator; the Core/Main Files \u201cmodule\u201d serves as the main form of reading publish-subscribe messages, as well as writing final Prediction output. Thus, any dependencies to or from these modules were unexpected. There were two dependencies between sub-modules that were seemingly absent in the concrete architecture. The first was the dependency from Predictor to Evaluator; this was displayed as a direct sequential flow in the visualization within the README. However, comments in the Predictor sub-module suggest that this dependency exists, but instead in a publish-subscribe communication format. [GitHub] The other discrepancy was the dependency from Evaluator to Scenario; as with the other dependency, this was expected due to the README, but was missing. As Evaluator largely uses machine learning in its implementation, generating various paths and corresponding probabilities, the scenario may not be as relevant. Inter-module publish-subscribe topics were expected to be read by the Container, as it stores their input data; however, this is absent in the concrete architecture. Instead, these topics are read by the Prediction component\u2019s Core/Main Files. This module also publishes to the ADCTrajectoryContainer and SubmoduleOutput used by the Evaluator and Predictor. The Container, included in the Main Files, processes the received data from the main Prediction component file via ContainerSubmoduleProcess , rather than receiving it itself. Finally, various unanticipated direct dependencies from the sub-modules to other modules may be found. All four original modules depend on the Common module; the Evaluator and Predictor are Cyber RT components. The Container directly includes the Map, by including the hdmap_common.h file for its obstacles and obstacle clusters.","title":"Reflexion Analysis"},{"location":"assignment2/#use-cases","text":"","title":"Use Cases"},{"location":"assignment2/#use-case-1-lane-following","text":"Figure 10: Sequence diagram for the lane following use case, in accordance with the concrete architecture. In this first use case of lane following, the vehicle stays within a lane while following another car at a safe distance. The diagram in Figure 10 highlights the flow of publish-subscribe channel data. First, the Perception module reads subscribed Drivers messages, which it processes; using the LocalizationEstimate , as well as more sensor data, it determines the perceived obstacles and traffic light status, if applicable. Using published Stories , LocalizationEstimate , PerceptionObstacles , and the ADCTrajectory of the previous cycle, the Prediction module predicts trajectories for the obstacles. The Planning module then plans a trajectory using the PredictionObstacles , TrafficLightDetection , Stories , LocalizationEstimate , MapMsg , RoutingResponse , and Chassis ; it publishes the trajectory to the ADCTrajectory channel. This is used by the Control module, in addition to the Chassis and LocalizationEstimate , to create control commands. The Canbus then reads the ControlCommand to send them to the hardware.","title":"Use Case 1: Lane Following"},{"location":"assignment2/#use-case-2-unprotected-left-turn","text":"Figure 11: Sequence diagram for the Unprotected Left Turn use case, centered upon the Planning component. Use Case 2 is the Unprotected Left Turn scenario. In this scenario, the vehicle is to turn left at an intersection with a traffic light; \u201cunprotected\u201d refers to how the traffic light is not using specific turn lights (i.e., left-only). Figure 11 presents a sequence diagram for this use case, which was created after a study of the Planning component code. After the Planning component reads messages from Localization, Storytelling, Prediction, Routing, Canbus, Map, Perception, and itself, it runs various planners once to plan trajectories. These planners use a Scenario Manager, creating the scenario as well as its current stage (Approach if not yet at the intersection, Creep to move forward and survey, and Intersection Cruise to move through). Tasks are found in a Task Factory, including deciding on the speed and path. Once this is complete, the stage, and then scenario, is finished; the Planners generate the trajectory using trajectory generators, and the optimal trajectory is written to the ADCTrajectory topic. [GitHub]","title":"Use Case 2: Unprotected Left Turn"},{"location":"assignment2/#lessons-learned","text":"Certain unexpected things complicated the architecture derivation process. Firstly, Understand is unable to detect protobuf dependencies, which means some module dependencies are obscured since they occur in code generated from the protobuf files. Second, the Apollo developers do not write very descriptive commit messages, and most pull requests that were looked at as being relevant to our investigation had no description. Apollo, being a large system, has various modules that are regularly updated over time, and the documentation is not necessarily updated with it; in addition, it may be simplified to the true state of the system for readability purposes or complexity.","title":"Lessons Learned"},{"location":"assignment2/#glossary","text":"HMI: Human Machine Interface LiDAR: Light Detection and Ranging Conti radar: A radar sensor from Continental Engineering. Specifically, Apollo uses the Continental ARS-408-21 Radar package. PnC: Planning and Control CAN: Controller Area Network. A host-less messaging bus protocol primarily used with microcontrollers in automotive contexts.","title":"Glossary"},{"location":"assignment2/#references","text":"ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed March 21, 2022. Retrieved from https://github.com/ApolloAuto/apollo. ApolloAuto. \u201cPlanning README at 5.5.0.\u201d GitHub (2020). Retrieved from https://github.com/ApolloAuto/apollo/blob/r5.5.0/modules/planning/README.md. Behere, Sagar, and Martin T\u00f6rngren. \u201cA functional reference architecture for autonomous driving.\u201d KTH The Royal Institute of Technology, Brinellv\u00e4gen 83, Stockholm SE-10044, Sweden (2015): 143. Retrieved from https://www.sciencedirect.com/science/article/abs/pii/S0950584915002177. OBEIA. \u201cThe Conceptual Architecture of Apollo.\u201d February 20, 2022. Retrieved from https://obeia.github.io/assignment1/.","title":"References"},{"location":"assignment3/","text":"Apollo & the Vehicle State Provider: A Suggestion for Enhancement Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.) Abstract Apollo is an open-source autonomous driving platform supporting the development of systems for self-driving vehicles. Having been built and continually refined over many years, Apollo\u2019s architecture has understandably developed idiosyncrasies. As an improvement to the software system\u2019s architecture, we propose introducing a new module to be solely responsible for vehicle state. As well as proposing this new module and its functionality, we outline two potential implementations for realizing it following paradigms already present in the Apollo system. We then assess these potential implementations according to SAAM, as outlined by Kazman, Bass, Abowd, and Webb, to determine which is the most desirable approach. Our final determination is to continue with the primarily publish-subscribe architecture present in Apollo for the implementation of the new module. We finally review the risks that the selected implementation introduces and propose strategies, including a testing strategy, to mitigate these risks. Introduction Apollo is a platform dedicated to the development of autonomous vehicles, which continues to be in development itself. The complexity of autonomous driving combined with vehicle hardware brings intricate detail that has been, and must continue to be, considered as the system develops. To implement the system, Apollo\u2019s developers have utilized a largely publish-subscribe-based approach, creating components that are mainly decoupled, for functionality and enhancement. These components include a Planning module to plan a trajectory based on various factors such as perceived obstacles, traffic light status, and the route created by the system\u2019s Routing module; a Control module that transforms the Planning module\u2019s trajectory into commands for the vehicle to execute; and a Map module that holds various maps to be utilized in the system, including a \u201crelative map\u201d that is relative to the vehicle. Apollo is a system with a variety of valued non-functional, quality-based attributes; these include performance, modifiability, and reliability. As a platform for autonomous driving, performance and reliability of utmost importance: if the system does not perform well, such as within a certain timeframe, or is not reliable enough in its results, it can be unsafe for a vehicle to use on the road, meaning that it must be refined. The system must also be modifiable to suit other developer\u2019s needs, such as to create new scenarios to plan for, or to utilize in implementations for specific vehicles. This suggests that Apollo\u2019s architecture and design needs to be easy for other developers in this field to understand and modify. Apollo includes a variety of utilities and objects within its system\u2019s Common module, with one being the aptly named vehicle state provider. It provides information relating to the vehicle\u2019s state to modules that utilize this data in calculations, such as for planning a trajectory or generating control commands. However, the vehicle state is updated by other modules as they receive or process appropriate input. The vehicle state provider\u2019s strange placement as a Common utility should be reviewed to determine if an enhancement can be made to improve the system, such as to improve modularity and testability. It is the subject of our proposed enhancement, described in the following in more detail. Proposed Enhancement The vehicle state provider is a singleton object in the Apollo system that provides several other modules with a simplified and aggregated view of the state of the vehicle. Specifically, a VehicleState is a protobuf-defined class that combines elements of the Chassis and LocalizationEstimate message types, including vehicle position coordinates and kappa; pitch, roll and yaw angles; heading; linear and angular velocity and acceleration; driving mode; gear and steering wheel position; and the vehicle pose. The vehicle state provider maintains this model of the vehicle state and provides methods for querying the state properties. Updates to the vehicle state are performed when needed by other modules invoking the VehicleStateProvider::Update method with a LocalizationEstimate message and a Chassis message as arguments, from which all VehicleState properties are recalculated. The two messages are read by the invoking module from the correspondingly named Cyber RT channels, which are written to by the Localization and Canbus modules, respectively. The vehicle state and provider are currently found in the modules/common/vehicle_state directory of the Apollo codebase. The provider class is common::VehicleStateProvider , defined and implemented in the vehicle_state_provider.h and vehicle_state_provider.cc files, with accompanying unit tests in vehicle_state_provider_test.cc , all in the root of the aforementioned directory. The vehicle state model is defined in a protocol buffer definition file, modules/common/vehicle_state/proto/vehicle_state.proto , from which the C++ code for the common::VehicleState class is generated at build time by the protocol buffer compiler. As can be gathered from the code location and class namespace, the vehicle state provider exists within Apollo's Common module, which is otherwise responsible for providing other Apollo modules with generic utilities and global constants and is meant to be consumed as a dependency library. The inclusion of a specialized dynamic runtime data service in a common library module would be considered bad design practise by many. Even more so when the implementation of said service requires the Common module to take a dependency on a more specialized system component as is the case here, since the design paradigm of common modules typically allows them only to depend on external libraries. Given the abnormality in the architecture that the vehicle state provider introduces by being a part of the Common module, our suggested enhancement is its refactoring and isolation as a new module unto itself in the Apollo system. Motivation As described previously, the inclusion of the vehicle state provider as a part of the Common module is an architectural abnormality and case of bad design practise in Apollo. It is against the commonly accepted design paradigm of a shared utilities library, such as the Common module, to take dependencies on other, non-generic application modules. Common practice dictates that such library modules only depend on themselves, the language or runtime standard library, and external third-party dependencies (usage of which can be simplified for the rest of the project through the shared library). In this case, inclusion of the vehicle state provider requires dependencies on both the Canbus module via use of generated protobuf code for Chassis data, and the Localization module via use of generated protobuf code for LocalizationEstimate data as well as direct usage of Localization constants and configuration state flags. Furthermore, the vehicle state provider is, as its name suggests, a stateful runtime data service, that receives both updates and queries over the lifetime of a running Apollo process. That is also irregular as a part of a common shared library, which tend to contain stateless utilities, wrappers, and static or constant data. An earlier form of the vehicle state provider exists as far back as the initial commit to the Apollo repository, so it is hard to tell for certain, but its location as part of Common is possibly a case of \u201cjunk drawer\u201d degradation in a commons library, where anything that does not find an immediate other location is added to the commons. Aside from mostly informal best practices of shared module usage, the separation of vehicle state into a dedicated module allows the overall system architecture to be improved. Separation of the vehicle state provider from Common serves to increase overall cohesion by isolating the specialized functionality it provides from the more generic utilities provided by the rest of the Common module. The separation will also slightly reduce coupling as a baseline, by reducing the number of dependencies on Common, as well as preventing transitive dependencies via Common for modules that do not require the vehicle state provider. Coupling may be further reduced depending on the implementation that is chosen, which will be explored in greater detail in subsequent sections. It also serves to simplify understanding of the Apollo system overall, as an important piece of the operation of several modules will no longer be hidden among all the other dependencies on the Common module. An additional benefit of this dedicated vehicle state module is that it allows for future expansion of vehicle data points, especially ones that are aggregated or derived from multiple sources. For example, the chassis reports the estimated fuel range of the car, but this is just a simple reading that does not consider the rest of the system. Incorporating this into the vehicle state module by introducing a fuel sub module creates the opportunity to apply models on this data to improve the estimation accuracy and better planning. This can be done by logging the fuel along the route as well as the acceleration, velocity, and temperature among others. By having this learning model track vehicle state information, planning, routing, and control modules can determine highly accurate fuel usage as well as adjust trajectories to optimize fuel efficiency. Another important attribute that can be modeled is breaking distance; the perception module can gather and log information about the road surface and weather and temperature conditions so the vehicle can estimate a coefficient of friction between the tires and road surface and then calculate a minimum distance for stopping to improve safety. While the current scope of the vehicle state provider is limited, and the code implementing it is minimal, it provides a base to grow from that would be much easier to maintain and encapsulate once separated from Common. Current State Figure 1: Simplified view of the inter-module dependencies of Apollo\u2019s current architecture. Figure 2: Publish-subscribe communication of the current Apollo architecture. Figure 1 above presents the inter-module code dependencies of version 7.0 of the Apollo system, extracted using code analysis and the Understand tool. For simplicity, all modules with dependencies on Common are shown in green. While dependencies on generated protobuf code are not shown, the unusual dependency taken by Common on Localization, required by the vehicle state provider, is visible. Figure 2 presents the publish-subscribe communication dependencies between the Apollo modules at runtime. Some of the dependencies, namely the Map module\u2019s subscription to both Localization and Canbus, exist only to support the use of the vehicle state provider. Further details on these dependencies and the creation of these architectural views can be found in our group\u2019s previous report. [OBEIA] Figure 3: Inter- and intra-module dependencies of and on the vehicle state provider. The vehicle state provider code is found in the Common module and depends on basic utilities within Common such as status, math, and configs, as well as an inter-module dependency on Localization. Further, the Planning, Control, Map, and Task Manager modules directly make use of it, and are the only modules to currently do so. These dependencies were identified using Understand and can be seen in Figure 3. Effects on Architectures According to analysis of the system\u2019s source code via Understand, four submodules of Apollo currently utilize the vehicle state provider: the Map, Planning, Control, and Task Manager modules. The overall dependencies from these modules to Common would not be removed entirely, but instead, dependencies to the vehicle state provider unit would be moved. Further, some dependencies, such as Common depending on Localization for the vehicle state provider to choose how to determine linear acceleration and velocity, would be removed from Common to be a code dependency taken by the new vehicle state module has. Thus, the structure of the Common module would be the most affected, as this utility would become a component of its own, but would require minimal changes to the rest of the module\u2019s code. In the Map module, the relative map\u2019s navigation lane is built from the vehicle state, and upon receiving localization and chassis data via the corresponding Cyber RT channels, the state is also updated. Meanwhile, the Control module utilizes its own dependency injector implementation to hold a reference to the vehicle state provider and provide it for use by other submodules, including the core Control component, to both access and, upon receiving input, update the vehicle state. The Planning module currently contains the most direct dependencies to the vehicle state provider; many are within specific stages of scenarios. This module also uses its own dependency injector implementation to hold a reference to the state provider, which is used by other submodules, including stages. One example of this is found with Navi Planning: it uses the state to estimate the vehicle\u2019s future position, then updates its local view of the vehicle state to reflect this estimate, if within a certain timeframe of present time to the last update of this state. Further, while the Task Manager module\u2019s dead end routing manager refers to the vehicle state provider, it does not appear to currently use it, suggesting that this dependency is obsolete. Our proposed enhancement would thus, in the realization process, remove such dependencies. In addition to these modules, it should be noted that Apollo\u2019s system also includes a Monitor module that ensures that other components are working as expected. By removing the vehicle state provider from its place in the Common module and transforming it into its own component, the Monitor would also require regularly ensuring that the provider is functioning as expected. This is not something that currently occurs, so actually serves to increase monitoring of system functionality. Of final note is another, potentially out of place, item found in the Common module: the common::VehicleModel class. VehicleModel takes no dependency on the vehicle state provider, however it does make use of the VehicleState datatype in its operation, which requires a protobuf dependency. If we wish to ensure that no dependencies from Common to other modules existed as a result of this refactoring, the vehicle model would have to be refactored as well. Options would include either moving it to the new vehicle state module, or extracting it to a submodule of Planning, since it is quite specialized and only exists for use by Planning\u2019s trajectory stitcher. Analysis of what should be done with the VehicleModel class is outside the scope of this report. In summary, the overall Apollo system architecture will be affected by the restructuring, with some dependencies removed and others introduced. Internal to the modules, changes may be minimal, as the inner logic is largely unaware of how the vehicle state is being provided. Interactions with Other Features The vehicle state provider is an essential utility for many modules, each holding an important role, as noted previously. For example, the Map module\u2019s relative map is created using the vehicle state data, and the Planning module stages use the data in their planning processes. However, each module updates the vehicle state as well to suit their needs; for example, both the Map\u2019s relative map and the Control component update the vehicle state upon receiving their appropriate inputs to ensure that further processing is done on fresh data and not a stale vehicle state that is no longer accurate. Therefore, features that interact with the Vehicle State Provider, and thus would be affected directly by its refactoring, include: i) relative map creation, as the vehicle state is utilized and updated; ii) stage planning for various scenarios; iii) navigation (Navi) planning; and iv) control command creation, as the vehicle state is updated with its input. In summary, features such as map creation, trajectory planning, and control command creation\u2014all being relative to the vehicle state\u2014interact with the vehicle state provider. Implementation 1: Direct Code Dependencies One potential implementation of this refactoring would function similarly to the current vehicle state provider of the Common module, but instead would be its own module. Thus, direct code dependencies to the provider as implemented in the current system would now be to this new module. This implementation would require a singleton object, VehicleStateProvider , with various \u201cgetter\u201d functions which other modules may call as required. This implementation would still need an \u201cupdate\u201d method that must be called explicitly, as in the current system. It should be noted that the vehicle state provider must be safe for concurrent access and updating, as Apollo is a high-concurrency system, and the state is essential to many key parts of the autonomous system. Access and use of the state provider, and proper locking for thread safety, should be the responsibility of the new module, instead of each consuming module handling it in their own ways with custom dependency injectors or direct use of a shared pointer as is the current case. Impact As discussed previously, the impacted modules other than the newly created vehicle state provider would be Common, Planning, Control, Task Manager, and Map. The Task Manager\u2019s dependency on the provider in Common would be reviewed and likely removed, and Common\u2019s original vehicle state provider would be extracted to the dedicated module. This would remove Common\u2019s only inter-module dependency, on Localization. Other modules would see little change other than to their dependencies and potentially to the manner the state provider is accessed or acquired. However, while the architecture of the system would be affected, modules themselves would be affected minimally. The means of acquiring and accessing the vehicle state provider may change, but it would have little effect on the internal logic and operation of the modules. Architectural Styles The main architectural style utilized in this implementation would be an object-oriented style. This is in a way obvious, as a singleton object would have to be defined, meaning the implementation is oriented around an object. In this style, other objects\u2014in this case, the modules making use of the vehicle state provider\u2014would need to know the identities of this new object in question. Further, this style is also used to identify and protect specific data; the vehicle state provider is designed for this purpose, protecting and identifying a variety of information on the vehicle\u2019s state. In fact, it would be further protected and isolated from how it currently is, as stricter patterns for accessing it are enforced, rather than letting each consuming module choose its own approach. Implementation 2: Publish-Subscribe The second possible implementation of the refactoring would transform the vehicle state provider into a full standalone Cyber RT component in addition to being a new module. As a component in Cyber RT, the vehicle state component would declare listeners for LocalizationEstimate and Chassis messages in order to provide an accurate vehicle state. Whenever there is an update in the form of a new message on the appropriate channels, the component logic would trigger to process it and update an internal VehicleState model. It then publishes the latest VehicleState to a new topic of the same name that is unique to this implementation. Modules dependent on the current vehicle state provider would instead subscribe to this new topic, from which they will receive the latest vehicle state. Impact As discussed previously, the Common, Control, Planning, Map, and Task Manager modules would be affected. All direct dependencies to the vehicle state provider that are currently in the system would be removed from each module, and the original provider from Common\u2014as well as the singular code dependency on Localization that it utilizes\u2014extracted. In the current state of the system, the Control module\u2019s dependency injector only provides the vehicle state provider; as modules would instead be using a publish-subscribe approach to access vehicle state data, it would no longer be needed. However, that of the Planning module has other uses, so it would remain, only without the vehicle state provider access. Many modules and submodules would be directly affected by this implementation, as they would need to modify actions on how they access and update vehicle state data. Consumption of vehicle state data will be the most heavily affected. Each dependent module would declare an additional Cyber RT listener for the new VehicleState topic. Upon receiving a new vehicle state, a module may either immediately process it as needed, or simply hold onto it until it is required for other work and continue replacing the latest state data as new messages arrive. Both of these message consumption patterns are currently present in the Apollo system. For example, stages in the Planning module currently access the state provider directly; rather than increase the number of Cyber RT components drastically by adding them each as a listener, the Planning component could be updated so that it reads the required state data with a single listener, then shares it with the stages by providing them a pointer to where the latest state is stored in-memory. Other modules, such as Control, which make use of the vehicle state in many locations could follow a similar pattern, whereas Map which only uses it in one could have simpler logic that directly triggers from updated state data arriving. The other major change would be removing the requirement for modules to manually update the vehicle state before using it. With the standalone vehicle state component automatically updating the state as changes occur, the consuming modules are able to rely on their data being fresh and not requiring a manual update. Calls to the VehicleStateProvider::Update method can be removed entirely. Furthermore, the Map component\u2019s subscriptions to the LocalizationEstimate and Chassis topics exist only to allow relative map to update the vehicle state, so those dependencies can be removed. Architectural Styles The main architectural style utilized in this implementation would, of course, be the publish-subscribe style. By becoming a component in Cyber RT, the vehicle state provider is then able to publish and subscribe to topics, like many other modules in the system; Apollo is largely based on this style. The current vehicle state provider of the system is, as noted in how the architecture and features would be affected, often making use of these publish-subscribe messages such as in the Control module; thus, the vehicle state could instead make use of published topics as its own component. Various modules also request data from the provider; modules could instead receive the vehicle state as soon as it is published. SAAM Analysis The SAAM Analysis, created by Kazman, Bass, Abowd, and Webb, is a method for studying software with respect to their quality attributes, features, and architecture. By considering how non-functional requirements are affected by a new or existing feature, software architects and developers can determine how well the system supports the feature in its current state. [Kazman, Bass, Abowd, and Webb] By repeating this process for two different implementations of a feature, they can further determine which would better suit the software. To determine non-functional requirements, Apollo\u2019s major stakeholders and requirements are identified. Stakeholders The stakeholders for the proposed enhancement are all parties whose experience may be affected by implementation of the enhancement. Perhaps the most direct stakeholders are the developers assigned to improve and maintain Apollo software as the location of source code blocks and dependencies (either code or publish-subscribe) between modules would be changed. Another stakeholder with a similar perspective to developers is the technician. Technicians are those who would be fixing Apollo-equipped vehicles, and their domain may not be limited to just the software. The next stakeholder for the enhancement is the end user. While the developer may care about the structure of the software, the user only cares about the impact of changes on the experience of being a passenger in an Apollo vehicle, including factors like safety and convenience. Car manufacturers are another stakeholder that should be considered. Interestingly, manufacturers have overlapping interests with users and developers. In order to be successful in selling Apollo-equipped vehicles, manufacturers must be interested with providing the best user experience possible. On the development side, manufacturers must be interested in the costs associated with maintaining and implementing Apollo in vehicles. Non-Functional Requirements By analyzing the interests of each stakeholder, we can identify the most important non-functional requirements to be met by the enhancement. From the perspective of the end user, the software must have good performance, accuracy, reliability and security. Performance can be broken into several areas including smoothness of ride, energy efficiency and speed of vehicle response to road conditions. Another requirement of end users is accuracy. The software should be accurate in its interpretation of nearby objects, selection of routes, and its creation of control inputs to the physical hardware of the car. Furthermore, the system must be reliable. If the software is reliable this means that it is safe to use, and that maintenance is not required often. Finally, end users of Apollo require the system to be secure. Since Apollo is responsible for operating cars with passengers, a system that could be hacked would pose huge threats to the passengers of the Apollo-controlled vehicle as well as those in other vehicles. All these non-functional requirements, which are be influenced by the software\u2019s architecture, impact the experience of the user. The development team working on Apollo requires the code to be modifiable, maintainable and testable. Modifiability and maintainability allow improvements to be made to the software more easily. Good testability allows these modifications to be debugged. Technicians are in a similar category to developers in that they are responsible for maintaining vehicles, although their domain may be focused on the entire car as a whole, rather than just the software. They also would not be responsible for improving the software system, only maintaining it. Nonetheless, technicians that work on Apollo-equipped vehicles require manageability and supportability. Car manufacturers require good portability and testability. Good portability refers to the ability to easily implement the software system on different hardware platforms, specifically, different vehicles. This would matter to car manufacturers because they may have several different models within their lineup that will all need Apollo software. Testability is important because the manufacturer is responsible to ensure that their vehicles operate correctly. Analysis Table 1 presents the results of analyzing each attribute and how they may be affected by each implementation. It should be noted that certain attributes would be unaffected by either implementation, such as portability; however, as the vehicle state is utilized in various key features of the system, they remain of note. Table 1: How each quality attribute is affected by implementations of the enhancement Requirement | Implementation 1: Direct Code | Implementation 2: Pub-Sub --- | --- | --- Responsiveness | There would be little effect with respect to this requirement, as other modules would utilize the vehicle state provider similarly to their current implementations. By directly accessing the vehicle state, responsiveness is high. | The publish-subscribe style for this component would improve concurrency of the dependent components. However, there is also added overhead as components would no longer directly access the vehicle state. Accuracy | With current levels of concurrency, accuracy of the vehicle state must be ensured. The vehicle state provider would continue to be updated by other modules, having less control, but is currently accurate for development purposes. | As a dedicated component, the vehicle state provider itself can have more control over updating the vehicle state. As localization and chassis data is regularly published, accuracy may be increased further. Reliability | Certain components (Planning, Control, Map) must call to update the vehicle state provider manually, as in the current system. Otherwise, the state could get out of date, which severely decreases the system\u2019s reliability and puts the burden on developers remembering to include necessary calls to the update method. | The vehicle state provider auto-updates on new data as soon as it retrieves them from the subscribed topics. However, reliant modules must have the latest message to be accurate and therefore reliable in their calculations. This directly impacts the entire system\u2019s reliability due to reliant components being core to the system. Security | Permissions are regulated by the public and private keywords defined for the Vehicle State singleton object. | In the pub-sub architecture, permissions on access to vehicle state can be managed by access to the outgoing messages. Modifiability | Changes to objects must still work in all locations where they are referenced; this implementation brings more modularity to a degree, but other modules must ensure that the vehicle state is updated as appropriate. | This implementation would make the system more modular, as it would be easier to modify without affecting other code. Other modules would only read the VehicleState topic, having a looser connection (if any) to the update process. Maintainability | Any changes to vehicle state provider directly affect other modules, but due to the refactoring process described previously, this implementation would not strongly affect maintainability compared to the current system. | By increasing modifiability, maintainability also increases from a development view due to how the code becomes easier to maintain. From an operational view, maintainability is also improved as control of the vehicle state provider is increased. Testability | By transforming the vehicle state provider into its own module, testability is improved. | Moving the vehicle state into its own module makes it easier to isolate for testing. Supportability | By separating into its own module, developers, manufacturers and technicians may find it easier to support vehicle state-specific areas of the application, such as errors that users may encounter. | As in the direct code implementation, the enhancement itself increases supportability. Evaluation Both implementations proposed improve supportability, modifiability, and testability, due to the structure of the enhancement and its intended purposes. The vehicle state provider\u2019s separation and refactoring to a dedicated module improve the development process by improving vehicle state-related testing and increasing modularity within the system; this eases the development and testing of features and components, both present and not yet present within the system. Supportability is also improved as the system\u2019s deployment including this enhancement may make it more straightforward for those working with the system to utilize and understand vehicle state-related information. Security may also be improved with respect to the vehicle state provider in both implementations, albeit differently. The direct code implementation brings with it many of the same qualities as the current vehicle state provider implementation. For example, responsiveness and maintainability would not be strongly affected when compared to the current system, as methods of how the vehicle state is accessed and updated remain similar. However, system reliability may be at risk as developers must ensure the state is updated. While modifiability is improved by separating the vehicle state from the Common module, it could be improved further in this regard with another implementation. Finally, while the vehicle state is currently accurate for development purposes, other modules have control in updating it; as development continues, it should be studied to see if the state\u2019s accuracy is affected in the future. The publish-subscribe implementation improves maintainability further, both from a development perspective in the maintaining of code, as well as an operation perspective in the maintaining of the vehicle state itself. Modifiability is also further increased, as developers now have ensured that the vehicle state is updated upon new data, in addition to the transformation to a dedicated module easing state-related development. As with the other implementation, reliability and accuracy are coupled; the vehicle state would be updated as soon as new data is found, increasing accuracy, but it must be ensured that reliant modules have received the updated vehicle state before calculations begin, or otherwise the system\u2019s reliability may be at risk. Finally, while concurrency in the system is improved, there is a risk due to added overhead; thus, responsiveness is not necessarily improved by this implementation. Chosen Implementation Our evaluation of the SAAM analysis we performed for this enhancement led us to the conclusion that the publish-subscribe implementation would provide an overall better set of improved quality attributes. As discussed previously, the Task Manager would be affected by no longer needing to reference the vehicle state provider in its current state, whereas the Common module would no longer contain this utility and thus no longer need a dependency on Localization. The Control, Planning and Map modules are all currently components in Cyber RT; they would now also read messages from the VehicleState topic. Sub-components, such as scenarios in Planning, would require the latest VehicleState as input. The Monitor would also need to regularly ensure that the vehicle state provider is performing as expected. Effects on System NFR's As discussed in the SAAM analysis of this implementation, maintainability may be positively affected by this implementation. From a development perspective, its separation makes the vehicle state provider and the features utilizing it easier to maintain and update; there is less burden on ensuring the vehicle state is at its most recent. From an operational perspective, the publish-subscribe implementation also improves maintainability of the system by ensuring that as soon as data is published suggesting that the state has changed, the vehicle state is updated. The system\u2019s evolvability may also be positively affected, as modifiability is increased due to the vehicle state provider\u2019s separation into a new module. By making the system easier to modify, it also becomes easier to evolve in more major regards, provided that no major rehauls occur. Finally, by isolating the vehicle state provider and transforming it into its own dedicated module, the quality of the system\u2019s testability may also be improved. By becoming its own module, it becomes easier to isolate for testing purposes. However, responsiveness may be affected negatively by this implementation. While concurrency may be increased to some degree, there may also be added overhead as a consequence of the Vehicle State Provider becoming a publish-subscribe component rather than a directly accessed singleton object. This potential decrease in response time is a risk for the system. Use Cases Use Case 1 - Planning (Reading Vehicle State) Figure 4: Sequence diagram for reading the vehicle state, focusing on the Planning component. The first use case for the vehicle state provider is reading data from the vehicle state. This is done by various components; thus, this use case centers upon the Planning component and a scenario. It should be noted that many scenarios utilize the vehicle state, and while they may use it in different ways, this use case highlights how it is read by them. In the current system, this is read by shared pointers such as in the Map, and dependency injectors such as in Planning. However, with a publish-subscribe implementation of the proposed enhancement, components would instead read from the subscribed topic, VehicleState . Figure 4 presents a sequence diagram for this use case, based upon the system with the proposed enhancement implemented via publish-subscribe. The Planning component calls for the Planning Base to run once; the Base retrieves data from the VehicleState topic, and then plans. In the planning process, the Planner updates the Scenario Manager, which in turn calls ScenarioDispatch . Using a non-learning version of this function as well as the scenario type, the Scenario Manager finally returns a scenario. The Planner then begins its process, where within the given scenario, the VehicleState topic is read and retrieved. Use Case 2 (Updating Vehicle State) Figure 5: Sequence diagram for updating the vehicle state. The other possible use case for the current vehicle state provider is being updated. In the current system, the vehicle state is generally updated by other modules, such as Map and Control; however, with a publish-subscribe implementation of our proposed enhancement, the vehicle state would be instead updated upon localization or chassis data from Localization and Canbus, respectively. Figure 5 presents a sequence diagram for the use case, if the enhancement were implemented with a publish-subscribe approach. There are two possible cases: when new LocalizationEstimate data is published, and when new Chassis data is published. If the former is published, then it is retrieved and the vehicle state is updated with respect to localization; the vehicle state is then published to the VehicleState topic. A similar process occurs if Chassis data is published, but instead, the vehicle state is updated with respect to this chassis-related data. Plans for Testing Whenever modifying a systems architecture, it is crucial to test the enhancement. In this case, we will be adding a new Vehicle State component as a Cyber RT component. This neat separation of vehicle state into its own publish-subscribe module allows for much easier testing. Currently the logic for the vehicle state is spaced out among various parts of the architecture. This means that all components that have a dependency on vehicle state will have to be refactored to use the new Vehicle State module. Such a large restructuring can lead to many hard to predict errors. Thus, a full integration test is required, to ensure the other components work correctly with the new Vehicle State module. This testing would likely first take form of a dry run wherein the test isolates key functions that access vehicle state and ensure there are performing as before. Since this enhancement is exclusively a change to the architecture, we can test the results of the functions before and after the enhancement to ensure they are the same. The final form of testing would be a real-life scenario, with a real autonomous vehicle running the Apollo software. The test would ensure that the vehicle operates as normal. This test can use the Monitor and Dreamview modules to view real time information and ensure it is as expected. Potential Risks One of the main risks identified is the responsiveness of the software. Information about the vehicle state is critical and is required to be accessed quickly and frequently. This is best pictured by imagining a human driver. The driver, while not necessarily consciously aware, is continually assessing the state of the vehicle. If the engine were to stall and the gas pedal becomes unresponsive, the driver is immediately aware. If the brakes are applied, but perhaps due to ice, the vehicle does not decelerate as quickly as anticipated, the driver is immediately aware and able to respond. This responsiveness to vehicle state is perhaps even more critical for the Apollo autonomous software. Adding the Vehicle State as a pub sub module could add overhead in response time relative to directly accessing the data as is done presently. When enacting this enhancement, there must be clear bounds set on the response time of various queries to vehicle state. Lessons Learned Various complications occurred in the process of creating and determining implementations for a new feature or enhancement. When coming up with possible new features, we found that their implementations would be straightforward due to how Apollo is currently implemented. As we wanted to perform SAAM Analysis and determine an implementation for a less straightforward enhancement, this lengthened the process of choosing a new feature or enhancement. Once an enhancement was determined, we discovered that tasks would have to be done in order; we couldn\u2019t divide up some of the work until previous work was completed. For example, the SAAM Analysis was more serial than parallel, and the evaluation had to be completed before use cases for a chosen implementation could be worked on in detail. Glossary SAAM \u2013 Software Architecture Analysis Method; a method for describing architectures and how well they meet their non-functional requirements, or quality attributes, by studying these attributes with respect to various tasks. [Kazman, Bass, Abowd and Webb] References ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed April 11, 2022. Retrieved from https://github.com/ApolloAuto/apollo. Kazman, Rick et al. \u201cSAAM: A Method for Analyzing the Properties of Software Architectures,\u201d ICSE, 1994. Retrieved from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.8786&rep=rep1&type=pdf. OBEIA. \u201cThe Concrete Architecture of Apollo.\u201d March 21, 2022. Retrieved from https://obeia.github.io/assignment2/.","title":"Enhancement Proposal"},{"location":"assignment3/#apollo-the-vehicle-state-provider-a-suggestion-for-enhancement","text":"Click here to access this report as a PDF. (Requires Queen's University login.) Click here to access the accompanying presentation slides. (Requires Queen's University login.)","title":"Apollo &amp; the Vehicle State Provider: A Suggestion for Enhancement"},{"location":"assignment3/#abstract","text":"Apollo is an open-source autonomous driving platform supporting the development of systems for self-driving vehicles. Having been built and continually refined over many years, Apollo\u2019s architecture has understandably developed idiosyncrasies. As an improvement to the software system\u2019s architecture, we propose introducing a new module to be solely responsible for vehicle state. As well as proposing this new module and its functionality, we outline two potential implementations for realizing it following paradigms already present in the Apollo system. We then assess these potential implementations according to SAAM, as outlined by Kazman, Bass, Abowd, and Webb, to determine which is the most desirable approach. Our final determination is to continue with the primarily publish-subscribe architecture present in Apollo for the implementation of the new module. We finally review the risks that the selected implementation introduces and propose strategies, including a testing strategy, to mitigate these risks.","title":"Abstract"},{"location":"assignment3/#introduction","text":"Apollo is a platform dedicated to the development of autonomous vehicles, which continues to be in development itself. The complexity of autonomous driving combined with vehicle hardware brings intricate detail that has been, and must continue to be, considered as the system develops. To implement the system, Apollo\u2019s developers have utilized a largely publish-subscribe-based approach, creating components that are mainly decoupled, for functionality and enhancement. These components include a Planning module to plan a trajectory based on various factors such as perceived obstacles, traffic light status, and the route created by the system\u2019s Routing module; a Control module that transforms the Planning module\u2019s trajectory into commands for the vehicle to execute; and a Map module that holds various maps to be utilized in the system, including a \u201crelative map\u201d that is relative to the vehicle. Apollo is a system with a variety of valued non-functional, quality-based attributes; these include performance, modifiability, and reliability. As a platform for autonomous driving, performance and reliability of utmost importance: if the system does not perform well, such as within a certain timeframe, or is not reliable enough in its results, it can be unsafe for a vehicle to use on the road, meaning that it must be refined. The system must also be modifiable to suit other developer\u2019s needs, such as to create new scenarios to plan for, or to utilize in implementations for specific vehicles. This suggests that Apollo\u2019s architecture and design needs to be easy for other developers in this field to understand and modify. Apollo includes a variety of utilities and objects within its system\u2019s Common module, with one being the aptly named vehicle state provider. It provides information relating to the vehicle\u2019s state to modules that utilize this data in calculations, such as for planning a trajectory or generating control commands. However, the vehicle state is updated by other modules as they receive or process appropriate input. The vehicle state provider\u2019s strange placement as a Common utility should be reviewed to determine if an enhancement can be made to improve the system, such as to improve modularity and testability. It is the subject of our proposed enhancement, described in the following in more detail.","title":"Introduction"},{"location":"assignment3/#proposed-enhancement","text":"The vehicle state provider is a singleton object in the Apollo system that provides several other modules with a simplified and aggregated view of the state of the vehicle. Specifically, a VehicleState is a protobuf-defined class that combines elements of the Chassis and LocalizationEstimate message types, including vehicle position coordinates and kappa; pitch, roll and yaw angles; heading; linear and angular velocity and acceleration; driving mode; gear and steering wheel position; and the vehicle pose. The vehicle state provider maintains this model of the vehicle state and provides methods for querying the state properties. Updates to the vehicle state are performed when needed by other modules invoking the VehicleStateProvider::Update method with a LocalizationEstimate message and a Chassis message as arguments, from which all VehicleState properties are recalculated. The two messages are read by the invoking module from the correspondingly named Cyber RT channels, which are written to by the Localization and Canbus modules, respectively. The vehicle state and provider are currently found in the modules/common/vehicle_state directory of the Apollo codebase. The provider class is common::VehicleStateProvider , defined and implemented in the vehicle_state_provider.h and vehicle_state_provider.cc files, with accompanying unit tests in vehicle_state_provider_test.cc , all in the root of the aforementioned directory. The vehicle state model is defined in a protocol buffer definition file, modules/common/vehicle_state/proto/vehicle_state.proto , from which the C++ code for the common::VehicleState class is generated at build time by the protocol buffer compiler. As can be gathered from the code location and class namespace, the vehicle state provider exists within Apollo's Common module, which is otherwise responsible for providing other Apollo modules with generic utilities and global constants and is meant to be consumed as a dependency library. The inclusion of a specialized dynamic runtime data service in a common library module would be considered bad design practise by many. Even more so when the implementation of said service requires the Common module to take a dependency on a more specialized system component as is the case here, since the design paradigm of common modules typically allows them only to depend on external libraries. Given the abnormality in the architecture that the vehicle state provider introduces by being a part of the Common module, our suggested enhancement is its refactoring and isolation as a new module unto itself in the Apollo system.","title":"Proposed Enhancement"},{"location":"assignment3/#motivation","text":"As described previously, the inclusion of the vehicle state provider as a part of the Common module is an architectural abnormality and case of bad design practise in Apollo. It is against the commonly accepted design paradigm of a shared utilities library, such as the Common module, to take dependencies on other, non-generic application modules. Common practice dictates that such library modules only depend on themselves, the language or runtime standard library, and external third-party dependencies (usage of which can be simplified for the rest of the project through the shared library). In this case, inclusion of the vehicle state provider requires dependencies on both the Canbus module via use of generated protobuf code for Chassis data, and the Localization module via use of generated protobuf code for LocalizationEstimate data as well as direct usage of Localization constants and configuration state flags. Furthermore, the vehicle state provider is, as its name suggests, a stateful runtime data service, that receives both updates and queries over the lifetime of a running Apollo process. That is also irregular as a part of a common shared library, which tend to contain stateless utilities, wrappers, and static or constant data. An earlier form of the vehicle state provider exists as far back as the initial commit to the Apollo repository, so it is hard to tell for certain, but its location as part of Common is possibly a case of \u201cjunk drawer\u201d degradation in a commons library, where anything that does not find an immediate other location is added to the commons. Aside from mostly informal best practices of shared module usage, the separation of vehicle state into a dedicated module allows the overall system architecture to be improved. Separation of the vehicle state provider from Common serves to increase overall cohesion by isolating the specialized functionality it provides from the more generic utilities provided by the rest of the Common module. The separation will also slightly reduce coupling as a baseline, by reducing the number of dependencies on Common, as well as preventing transitive dependencies via Common for modules that do not require the vehicle state provider. Coupling may be further reduced depending on the implementation that is chosen, which will be explored in greater detail in subsequent sections. It also serves to simplify understanding of the Apollo system overall, as an important piece of the operation of several modules will no longer be hidden among all the other dependencies on the Common module. An additional benefit of this dedicated vehicle state module is that it allows for future expansion of vehicle data points, especially ones that are aggregated or derived from multiple sources. For example, the chassis reports the estimated fuel range of the car, but this is just a simple reading that does not consider the rest of the system. Incorporating this into the vehicle state module by introducing a fuel sub module creates the opportunity to apply models on this data to improve the estimation accuracy and better planning. This can be done by logging the fuel along the route as well as the acceleration, velocity, and temperature among others. By having this learning model track vehicle state information, planning, routing, and control modules can determine highly accurate fuel usage as well as adjust trajectories to optimize fuel efficiency. Another important attribute that can be modeled is breaking distance; the perception module can gather and log information about the road surface and weather and temperature conditions so the vehicle can estimate a coefficient of friction between the tires and road surface and then calculate a minimum distance for stopping to improve safety. While the current scope of the vehicle state provider is limited, and the code implementing it is minimal, it provides a base to grow from that would be much easier to maintain and encapsulate once separated from Common.","title":"Motivation"},{"location":"assignment3/#current-state","text":"Figure 1: Simplified view of the inter-module dependencies of Apollo\u2019s current architecture. Figure 2: Publish-subscribe communication of the current Apollo architecture. Figure 1 above presents the inter-module code dependencies of version 7.0 of the Apollo system, extracted using code analysis and the Understand tool. For simplicity, all modules with dependencies on Common are shown in green. While dependencies on generated protobuf code are not shown, the unusual dependency taken by Common on Localization, required by the vehicle state provider, is visible. Figure 2 presents the publish-subscribe communication dependencies between the Apollo modules at runtime. Some of the dependencies, namely the Map module\u2019s subscription to both Localization and Canbus, exist only to support the use of the vehicle state provider. Further details on these dependencies and the creation of these architectural views can be found in our group\u2019s previous report. [OBEIA] Figure 3: Inter- and intra-module dependencies of and on the vehicle state provider. The vehicle state provider code is found in the Common module and depends on basic utilities within Common such as status, math, and configs, as well as an inter-module dependency on Localization. Further, the Planning, Control, Map, and Task Manager modules directly make use of it, and are the only modules to currently do so. These dependencies were identified using Understand and can be seen in Figure 3.","title":"Current State"},{"location":"assignment3/#effects-on-architectures","text":"According to analysis of the system\u2019s source code via Understand, four submodules of Apollo currently utilize the vehicle state provider: the Map, Planning, Control, and Task Manager modules. The overall dependencies from these modules to Common would not be removed entirely, but instead, dependencies to the vehicle state provider unit would be moved. Further, some dependencies, such as Common depending on Localization for the vehicle state provider to choose how to determine linear acceleration and velocity, would be removed from Common to be a code dependency taken by the new vehicle state module has. Thus, the structure of the Common module would be the most affected, as this utility would become a component of its own, but would require minimal changes to the rest of the module\u2019s code. In the Map module, the relative map\u2019s navigation lane is built from the vehicle state, and upon receiving localization and chassis data via the corresponding Cyber RT channels, the state is also updated. Meanwhile, the Control module utilizes its own dependency injector implementation to hold a reference to the vehicle state provider and provide it for use by other submodules, including the core Control component, to both access and, upon receiving input, update the vehicle state. The Planning module currently contains the most direct dependencies to the vehicle state provider; many are within specific stages of scenarios. This module also uses its own dependency injector implementation to hold a reference to the state provider, which is used by other submodules, including stages. One example of this is found with Navi Planning: it uses the state to estimate the vehicle\u2019s future position, then updates its local view of the vehicle state to reflect this estimate, if within a certain timeframe of present time to the last update of this state. Further, while the Task Manager module\u2019s dead end routing manager refers to the vehicle state provider, it does not appear to currently use it, suggesting that this dependency is obsolete. Our proposed enhancement would thus, in the realization process, remove such dependencies. In addition to these modules, it should be noted that Apollo\u2019s system also includes a Monitor module that ensures that other components are working as expected. By removing the vehicle state provider from its place in the Common module and transforming it into its own component, the Monitor would also require regularly ensuring that the provider is functioning as expected. This is not something that currently occurs, so actually serves to increase monitoring of system functionality. Of final note is another, potentially out of place, item found in the Common module: the common::VehicleModel class. VehicleModel takes no dependency on the vehicle state provider, however it does make use of the VehicleState datatype in its operation, which requires a protobuf dependency. If we wish to ensure that no dependencies from Common to other modules existed as a result of this refactoring, the vehicle model would have to be refactored as well. Options would include either moving it to the new vehicle state module, or extracting it to a submodule of Planning, since it is quite specialized and only exists for use by Planning\u2019s trajectory stitcher. Analysis of what should be done with the VehicleModel class is outside the scope of this report. In summary, the overall Apollo system architecture will be affected by the restructuring, with some dependencies removed and others introduced. Internal to the modules, changes may be minimal, as the inner logic is largely unaware of how the vehicle state is being provided.","title":"Effects on Architectures"},{"location":"assignment3/#interactions-with-other-features","text":"The vehicle state provider is an essential utility for many modules, each holding an important role, as noted previously. For example, the Map module\u2019s relative map is created using the vehicle state data, and the Planning module stages use the data in their planning processes. However, each module updates the vehicle state as well to suit their needs; for example, both the Map\u2019s relative map and the Control component update the vehicle state upon receiving their appropriate inputs to ensure that further processing is done on fresh data and not a stale vehicle state that is no longer accurate. Therefore, features that interact with the Vehicle State Provider, and thus would be affected directly by its refactoring, include: i) relative map creation, as the vehicle state is utilized and updated; ii) stage planning for various scenarios; iii) navigation (Navi) planning; and iv) control command creation, as the vehicle state is updated with its input. In summary, features such as map creation, trajectory planning, and control command creation\u2014all being relative to the vehicle state\u2014interact with the vehicle state provider.","title":"Interactions with Other Features"},{"location":"assignment3/#implementation-1-direct-code-dependencies","text":"One potential implementation of this refactoring would function similarly to the current vehicle state provider of the Common module, but instead would be its own module. Thus, direct code dependencies to the provider as implemented in the current system would now be to this new module. This implementation would require a singleton object, VehicleStateProvider , with various \u201cgetter\u201d functions which other modules may call as required. This implementation would still need an \u201cupdate\u201d method that must be called explicitly, as in the current system. It should be noted that the vehicle state provider must be safe for concurrent access and updating, as Apollo is a high-concurrency system, and the state is essential to many key parts of the autonomous system. Access and use of the state provider, and proper locking for thread safety, should be the responsibility of the new module, instead of each consuming module handling it in their own ways with custom dependency injectors or direct use of a shared pointer as is the current case.","title":"Implementation 1: Direct Code Dependencies"},{"location":"assignment3/#impact","text":"As discussed previously, the impacted modules other than the newly created vehicle state provider would be Common, Planning, Control, Task Manager, and Map. The Task Manager\u2019s dependency on the provider in Common would be reviewed and likely removed, and Common\u2019s original vehicle state provider would be extracted to the dedicated module. This would remove Common\u2019s only inter-module dependency, on Localization. Other modules would see little change other than to their dependencies and potentially to the manner the state provider is accessed or acquired. However, while the architecture of the system would be affected, modules themselves would be affected minimally. The means of acquiring and accessing the vehicle state provider may change, but it would have little effect on the internal logic and operation of the modules.","title":"Impact"},{"location":"assignment3/#architectural-styles","text":"The main architectural style utilized in this implementation would be an object-oriented style. This is in a way obvious, as a singleton object would have to be defined, meaning the implementation is oriented around an object. In this style, other objects\u2014in this case, the modules making use of the vehicle state provider\u2014would need to know the identities of this new object in question. Further, this style is also used to identify and protect specific data; the vehicle state provider is designed for this purpose, protecting and identifying a variety of information on the vehicle\u2019s state. In fact, it would be further protected and isolated from how it currently is, as stricter patterns for accessing it are enforced, rather than letting each consuming module choose its own approach.","title":"Architectural Styles"},{"location":"assignment3/#implementation-2-publish-subscribe","text":"The second possible implementation of the refactoring would transform the vehicle state provider into a full standalone Cyber RT component in addition to being a new module. As a component in Cyber RT, the vehicle state component would declare listeners for LocalizationEstimate and Chassis messages in order to provide an accurate vehicle state. Whenever there is an update in the form of a new message on the appropriate channels, the component logic would trigger to process it and update an internal VehicleState model. It then publishes the latest VehicleState to a new topic of the same name that is unique to this implementation. Modules dependent on the current vehicle state provider would instead subscribe to this new topic, from which they will receive the latest vehicle state.","title":"Implementation 2: Publish-Subscribe"},{"location":"assignment3/#impact_1","text":"As discussed previously, the Common, Control, Planning, Map, and Task Manager modules would be affected. All direct dependencies to the vehicle state provider that are currently in the system would be removed from each module, and the original provider from Common\u2014as well as the singular code dependency on Localization that it utilizes\u2014extracted. In the current state of the system, the Control module\u2019s dependency injector only provides the vehicle state provider; as modules would instead be using a publish-subscribe approach to access vehicle state data, it would no longer be needed. However, that of the Planning module has other uses, so it would remain, only without the vehicle state provider access. Many modules and submodules would be directly affected by this implementation, as they would need to modify actions on how they access and update vehicle state data. Consumption of vehicle state data will be the most heavily affected. Each dependent module would declare an additional Cyber RT listener for the new VehicleState topic. Upon receiving a new vehicle state, a module may either immediately process it as needed, or simply hold onto it until it is required for other work and continue replacing the latest state data as new messages arrive. Both of these message consumption patterns are currently present in the Apollo system. For example, stages in the Planning module currently access the state provider directly; rather than increase the number of Cyber RT components drastically by adding them each as a listener, the Planning component could be updated so that it reads the required state data with a single listener, then shares it with the stages by providing them a pointer to where the latest state is stored in-memory. Other modules, such as Control, which make use of the vehicle state in many locations could follow a similar pattern, whereas Map which only uses it in one could have simpler logic that directly triggers from updated state data arriving. The other major change would be removing the requirement for modules to manually update the vehicle state before using it. With the standalone vehicle state component automatically updating the state as changes occur, the consuming modules are able to rely on their data being fresh and not requiring a manual update. Calls to the VehicleStateProvider::Update method can be removed entirely. Furthermore, the Map component\u2019s subscriptions to the LocalizationEstimate and Chassis topics exist only to allow relative map to update the vehicle state, so those dependencies can be removed.","title":"Impact"},{"location":"assignment3/#architectural-styles_1","text":"The main architectural style utilized in this implementation would, of course, be the publish-subscribe style. By becoming a component in Cyber RT, the vehicle state provider is then able to publish and subscribe to topics, like many other modules in the system; Apollo is largely based on this style. The current vehicle state provider of the system is, as noted in how the architecture and features would be affected, often making use of these publish-subscribe messages such as in the Control module; thus, the vehicle state could instead make use of published topics as its own component. Various modules also request data from the provider; modules could instead receive the vehicle state as soon as it is published.","title":"Architectural Styles"},{"location":"assignment3/#saam-analysis","text":"The SAAM Analysis, created by Kazman, Bass, Abowd, and Webb, is a method for studying software with respect to their quality attributes, features, and architecture. By considering how non-functional requirements are affected by a new or existing feature, software architects and developers can determine how well the system supports the feature in its current state. [Kazman, Bass, Abowd, and Webb] By repeating this process for two different implementations of a feature, they can further determine which would better suit the software. To determine non-functional requirements, Apollo\u2019s major stakeholders and requirements are identified.","title":"SAAM Analysis"},{"location":"assignment3/#stakeholders","text":"The stakeholders for the proposed enhancement are all parties whose experience may be affected by implementation of the enhancement. Perhaps the most direct stakeholders are the developers assigned to improve and maintain Apollo software as the location of source code blocks and dependencies (either code or publish-subscribe) between modules would be changed. Another stakeholder with a similar perspective to developers is the technician. Technicians are those who would be fixing Apollo-equipped vehicles, and their domain may not be limited to just the software. The next stakeholder for the enhancement is the end user. While the developer may care about the structure of the software, the user only cares about the impact of changes on the experience of being a passenger in an Apollo vehicle, including factors like safety and convenience. Car manufacturers are another stakeholder that should be considered. Interestingly, manufacturers have overlapping interests with users and developers. In order to be successful in selling Apollo-equipped vehicles, manufacturers must be interested with providing the best user experience possible. On the development side, manufacturers must be interested in the costs associated with maintaining and implementing Apollo in vehicles.","title":"Stakeholders"},{"location":"assignment3/#non-functional-requirements","text":"By analyzing the interests of each stakeholder, we can identify the most important non-functional requirements to be met by the enhancement. From the perspective of the end user, the software must have good performance, accuracy, reliability and security. Performance can be broken into several areas including smoothness of ride, energy efficiency and speed of vehicle response to road conditions. Another requirement of end users is accuracy. The software should be accurate in its interpretation of nearby objects, selection of routes, and its creation of control inputs to the physical hardware of the car. Furthermore, the system must be reliable. If the software is reliable this means that it is safe to use, and that maintenance is not required often. Finally, end users of Apollo require the system to be secure. Since Apollo is responsible for operating cars with passengers, a system that could be hacked would pose huge threats to the passengers of the Apollo-controlled vehicle as well as those in other vehicles. All these non-functional requirements, which are be influenced by the software\u2019s architecture, impact the experience of the user. The development team working on Apollo requires the code to be modifiable, maintainable and testable. Modifiability and maintainability allow improvements to be made to the software more easily. Good testability allows these modifications to be debugged. Technicians are in a similar category to developers in that they are responsible for maintaining vehicles, although their domain may be focused on the entire car as a whole, rather than just the software. They also would not be responsible for improving the software system, only maintaining it. Nonetheless, technicians that work on Apollo-equipped vehicles require manageability and supportability. Car manufacturers require good portability and testability. Good portability refers to the ability to easily implement the software system on different hardware platforms, specifically, different vehicles. This would matter to car manufacturers because they may have several different models within their lineup that will all need Apollo software. Testability is important because the manufacturer is responsible to ensure that their vehicles operate correctly.","title":"Non-Functional Requirements"},{"location":"assignment3/#analysis","text":"Table 1 presents the results of analyzing each attribute and how they may be affected by each implementation. It should be noted that certain attributes would be unaffected by either implementation, such as portability; however, as the vehicle state is utilized in various key features of the system, they remain of note. Table 1: How each quality attribute is affected by implementations of the enhancement Requirement | Implementation 1: Direct Code | Implementation 2: Pub-Sub --- | --- | --- Responsiveness | There would be little effect with respect to this requirement, as other modules would utilize the vehicle state provider similarly to their current implementations. By directly accessing the vehicle state, responsiveness is high. | The publish-subscribe style for this component would improve concurrency of the dependent components. However, there is also added overhead as components would no longer directly access the vehicle state. Accuracy | With current levels of concurrency, accuracy of the vehicle state must be ensured. The vehicle state provider would continue to be updated by other modules, having less control, but is currently accurate for development purposes. | As a dedicated component, the vehicle state provider itself can have more control over updating the vehicle state. As localization and chassis data is regularly published, accuracy may be increased further. Reliability | Certain components (Planning, Control, Map) must call to update the vehicle state provider manually, as in the current system. Otherwise, the state could get out of date, which severely decreases the system\u2019s reliability and puts the burden on developers remembering to include necessary calls to the update method. | The vehicle state provider auto-updates on new data as soon as it retrieves them from the subscribed topics. However, reliant modules must have the latest message to be accurate and therefore reliable in their calculations. This directly impacts the entire system\u2019s reliability due to reliant components being core to the system. Security | Permissions are regulated by the public and private keywords defined for the Vehicle State singleton object. | In the pub-sub architecture, permissions on access to vehicle state can be managed by access to the outgoing messages. Modifiability | Changes to objects must still work in all locations where they are referenced; this implementation brings more modularity to a degree, but other modules must ensure that the vehicle state is updated as appropriate. | This implementation would make the system more modular, as it would be easier to modify without affecting other code. Other modules would only read the VehicleState topic, having a looser connection (if any) to the update process. Maintainability | Any changes to vehicle state provider directly affect other modules, but due to the refactoring process described previously, this implementation would not strongly affect maintainability compared to the current system. | By increasing modifiability, maintainability also increases from a development view due to how the code becomes easier to maintain. From an operational view, maintainability is also improved as control of the vehicle state provider is increased. Testability | By transforming the vehicle state provider into its own module, testability is improved. | Moving the vehicle state into its own module makes it easier to isolate for testing. Supportability | By separating into its own module, developers, manufacturers and technicians may find it easier to support vehicle state-specific areas of the application, such as errors that users may encounter. | As in the direct code implementation, the enhancement itself increases supportability.","title":"Analysis"},{"location":"assignment3/#evaluation","text":"Both implementations proposed improve supportability, modifiability, and testability, due to the structure of the enhancement and its intended purposes. The vehicle state provider\u2019s separation and refactoring to a dedicated module improve the development process by improving vehicle state-related testing and increasing modularity within the system; this eases the development and testing of features and components, both present and not yet present within the system. Supportability is also improved as the system\u2019s deployment including this enhancement may make it more straightforward for those working with the system to utilize and understand vehicle state-related information. Security may also be improved with respect to the vehicle state provider in both implementations, albeit differently. The direct code implementation brings with it many of the same qualities as the current vehicle state provider implementation. For example, responsiveness and maintainability would not be strongly affected when compared to the current system, as methods of how the vehicle state is accessed and updated remain similar. However, system reliability may be at risk as developers must ensure the state is updated. While modifiability is improved by separating the vehicle state from the Common module, it could be improved further in this regard with another implementation. Finally, while the vehicle state is currently accurate for development purposes, other modules have control in updating it; as development continues, it should be studied to see if the state\u2019s accuracy is affected in the future. The publish-subscribe implementation improves maintainability further, both from a development perspective in the maintaining of code, as well as an operation perspective in the maintaining of the vehicle state itself. Modifiability is also further increased, as developers now have ensured that the vehicle state is updated upon new data, in addition to the transformation to a dedicated module easing state-related development. As with the other implementation, reliability and accuracy are coupled; the vehicle state would be updated as soon as new data is found, increasing accuracy, but it must be ensured that reliant modules have received the updated vehicle state before calculations begin, or otherwise the system\u2019s reliability may be at risk. Finally, while concurrency in the system is improved, there is a risk due to added overhead; thus, responsiveness is not necessarily improved by this implementation.","title":"Evaluation"},{"location":"assignment3/#chosen-implementation","text":"Our evaluation of the SAAM analysis we performed for this enhancement led us to the conclusion that the publish-subscribe implementation would provide an overall better set of improved quality attributes. As discussed previously, the Task Manager would be affected by no longer needing to reference the vehicle state provider in its current state, whereas the Common module would no longer contain this utility and thus no longer need a dependency on Localization. The Control, Planning and Map modules are all currently components in Cyber RT; they would now also read messages from the VehicleState topic. Sub-components, such as scenarios in Planning, would require the latest VehicleState as input. The Monitor would also need to regularly ensure that the vehicle state provider is performing as expected.","title":"Chosen Implementation"},{"location":"assignment3/#effects-on-system-nfrs","text":"As discussed in the SAAM analysis of this implementation, maintainability may be positively affected by this implementation. From a development perspective, its separation makes the vehicle state provider and the features utilizing it easier to maintain and update; there is less burden on ensuring the vehicle state is at its most recent. From an operational perspective, the publish-subscribe implementation also improves maintainability of the system by ensuring that as soon as data is published suggesting that the state has changed, the vehicle state is updated. The system\u2019s evolvability may also be positively affected, as modifiability is increased due to the vehicle state provider\u2019s separation into a new module. By making the system easier to modify, it also becomes easier to evolve in more major regards, provided that no major rehauls occur. Finally, by isolating the vehicle state provider and transforming it into its own dedicated module, the quality of the system\u2019s testability may also be improved. By becoming its own module, it becomes easier to isolate for testing purposes. However, responsiveness may be affected negatively by this implementation. While concurrency may be increased to some degree, there may also be added overhead as a consequence of the Vehicle State Provider becoming a publish-subscribe component rather than a directly accessed singleton object. This potential decrease in response time is a risk for the system.","title":"Effects on System NFR's"},{"location":"assignment3/#use-cases","text":"","title":"Use Cases"},{"location":"assignment3/#use-case-1-planning-reading-vehicle-state","text":"Figure 4: Sequence diagram for reading the vehicle state, focusing on the Planning component. The first use case for the vehicle state provider is reading data from the vehicle state. This is done by various components; thus, this use case centers upon the Planning component and a scenario. It should be noted that many scenarios utilize the vehicle state, and while they may use it in different ways, this use case highlights how it is read by them. In the current system, this is read by shared pointers such as in the Map, and dependency injectors such as in Planning. However, with a publish-subscribe implementation of the proposed enhancement, components would instead read from the subscribed topic, VehicleState . Figure 4 presents a sequence diagram for this use case, based upon the system with the proposed enhancement implemented via publish-subscribe. The Planning component calls for the Planning Base to run once; the Base retrieves data from the VehicleState topic, and then plans. In the planning process, the Planner updates the Scenario Manager, which in turn calls ScenarioDispatch . Using a non-learning version of this function as well as the scenario type, the Scenario Manager finally returns a scenario. The Planner then begins its process, where within the given scenario, the VehicleState topic is read and retrieved.","title":"Use Case 1 - Planning (Reading Vehicle State)"},{"location":"assignment3/#use-case-2-updating-vehicle-state","text":"Figure 5: Sequence diagram for updating the vehicle state. The other possible use case for the current vehicle state provider is being updated. In the current system, the vehicle state is generally updated by other modules, such as Map and Control; however, with a publish-subscribe implementation of our proposed enhancement, the vehicle state would be instead updated upon localization or chassis data from Localization and Canbus, respectively. Figure 5 presents a sequence diagram for the use case, if the enhancement were implemented with a publish-subscribe approach. There are two possible cases: when new LocalizationEstimate data is published, and when new Chassis data is published. If the former is published, then it is retrieved and the vehicle state is updated with respect to localization; the vehicle state is then published to the VehicleState topic. A similar process occurs if Chassis data is published, but instead, the vehicle state is updated with respect to this chassis-related data.","title":"Use Case 2 (Updating Vehicle State)"},{"location":"assignment3/#plans-for-testing","text":"Whenever modifying a systems architecture, it is crucial to test the enhancement. In this case, we will be adding a new Vehicle State component as a Cyber RT component. This neat separation of vehicle state into its own publish-subscribe module allows for much easier testing. Currently the logic for the vehicle state is spaced out among various parts of the architecture. This means that all components that have a dependency on vehicle state will have to be refactored to use the new Vehicle State module. Such a large restructuring can lead to many hard to predict errors. Thus, a full integration test is required, to ensure the other components work correctly with the new Vehicle State module. This testing would likely first take form of a dry run wherein the test isolates key functions that access vehicle state and ensure there are performing as before. Since this enhancement is exclusively a change to the architecture, we can test the results of the functions before and after the enhancement to ensure they are the same. The final form of testing would be a real-life scenario, with a real autonomous vehicle running the Apollo software. The test would ensure that the vehicle operates as normal. This test can use the Monitor and Dreamview modules to view real time information and ensure it is as expected.","title":"Plans for Testing"},{"location":"assignment3/#potential-risks","text":"One of the main risks identified is the responsiveness of the software. Information about the vehicle state is critical and is required to be accessed quickly and frequently. This is best pictured by imagining a human driver. The driver, while not necessarily consciously aware, is continually assessing the state of the vehicle. If the engine were to stall and the gas pedal becomes unresponsive, the driver is immediately aware. If the brakes are applied, but perhaps due to ice, the vehicle does not decelerate as quickly as anticipated, the driver is immediately aware and able to respond. This responsiveness to vehicle state is perhaps even more critical for the Apollo autonomous software. Adding the Vehicle State as a pub sub module could add overhead in response time relative to directly accessing the data as is done presently. When enacting this enhancement, there must be clear bounds set on the response time of various queries to vehicle state.","title":"Potential Risks"},{"location":"assignment3/#lessons-learned","text":"Various complications occurred in the process of creating and determining implementations for a new feature or enhancement. When coming up with possible new features, we found that their implementations would be straightforward due to how Apollo is currently implemented. As we wanted to perform SAAM Analysis and determine an implementation for a less straightforward enhancement, this lengthened the process of choosing a new feature or enhancement. Once an enhancement was determined, we discovered that tasks would have to be done in order; we couldn\u2019t divide up some of the work until previous work was completed. For example, the SAAM Analysis was more serial than parallel, and the evaluation had to be completed before use cases for a chosen implementation could be worked on in detail.","title":"Lessons Learned"},{"location":"assignment3/#glossary","text":"SAAM \u2013 Software Architecture Analysis Method; a method for describing architectures and how well they meet their non-functional requirements, or quality attributes, by studying these attributes with respect to various tasks. [Kazman, Bass, Abowd and Webb]","title":"Glossary"},{"location":"assignment3/#references","text":"ApolloAuto. \u201cApolloAuto/apollo: An open autonomous driving platform.\u201d GitHub. Last accessed April 11, 2022. Retrieved from https://github.com/ApolloAuto/apollo. Kazman, Rick et al. \u201cSAAM: A Method for Analyzing the Properties of Software Architectures,\u201d ICSE, 1994. Retrieved from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.8786&rep=rep1&type=pdf. OBEIA. \u201cThe Concrete Architecture of Apollo.\u201d March 21, 2022. Retrieved from https://obeia.github.io/assignment2/.","title":"References"}]}